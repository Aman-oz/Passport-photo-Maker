<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ots/aipassportphotomaker/common/utils/DrawViewAction.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ots/aipassportphotomaker/common/utils/DrawViewAction.kt" />
              <option name="originalContent" value="package com.ots.aipassportphotomaker.common.utils&#10;&#10;enum class DrawViewAction {&#10;    ERASE_BACKGROUND,    // Remove background by dragging&#10;    RECOVER_AREA,        // Recover erased areas with brush&#10;    TRANSFORM,           // Move/Scale/Rotate the image&#10;    NONE&#10;}&#10;" />
              <option name="updatedContent" value="package com.ots.aipassportphotomaker.common.utils&#10;&#10;enum class DrawViewAction {&#10;    ERASE_BACKGROUND,    // Remove background by dragging&#10;    RECOVER_AREA,        // Recover erased areas with brush&#10;    TRANSFORM,           // Move/Scale/Rotate the image&#10;    NONE&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ots/aipassportphotomaker/common/utils/GraphicOverlay.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ots/aipassportphotomaker/common/utils/GraphicOverlay.kt" />
              <option name="originalContent" value="package com.ots.aipassportphotomaker.common.utils&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.Canvas&#10;import android.graphics.Color&#10;import android.graphics.Matrix&#10;import android.graphics.Paint&#10;import android.graphics.Path&#10;import android.graphics.PorterDuff&#10;import android.graphics.PorterDuffXfermode&#10;import android.util.AttributeSet&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.widget.ImageView&#10;import com.ots.aipassportphotomaker.common.utils.BitmapUtils.isMemorySufficient&#10;import java.util.Stack&#10;import kotlin.math.atan2&#10;import kotlin.math.sqrt&#10;&#10;// Transformation mode constants&#10;private const val TRANSFORM_NONE = 0&#10;private const val TRANSFORM_DRAG = 1&#10;private const val TRANSFORM_ZOOM = 2&#10;private const val TOUCH_TOLERANCE = 4f&#10;&#10;/**&#10; * Created by Aman Ullah&#10; * Sr. Software Engineer Android&#10; * Created on 13 Aug,2025 15:20&#10; * Copyright (c) All rights reserved.&#10; */&#10;&#10;&#10;/**&#10; * A view which renders a series of custom graphics to be overlayed on top of an associated preview&#10; * (i.e., the camera preview). The creator can add graphics objects, update the objects, and remove&#10; * them, triggering the appropriate drawing and invalidation within the view.&#10; *&#10; *&#10; * Supports scaling and mirroring of the graphics relative the camera's preview properties. The&#10; * idea is that detection items are expressed in terms of an image size, but need to be scaled up&#10; * to the full view size, and also mirrored in the case of the front-facing camera.&#10; *&#10; *&#10; * Associated [Graphic] items should use the following methods to convert to view&#10; * coordinates for the graphics that are drawn:&#10; *&#10; *&#10; *  1. [Graphic.scale] adjusts the size of the supplied value from the image scale&#10; * to the view scale.&#10; *  1. [Graphic.translateX] and [Graphic.translateY] adjust the&#10; * coordinate from the image's coordinate system to the view coordinate system.&#10; *&#10; */&#10;&#10;&#10;open class GraphicOverlay(context: Context?, attrs: AttributeSet?) : View(context, attrs) {&#10;&#10;    private val TAG = GraphicOverlay::class.java.simpleName&#10;&#10;    private val transformationMatrix = Matrix()&#10;    var imageWidth = 0&#10;        private set&#10;    var imageHeight = 0&#10;        private set&#10;&#10;    private var scaleFactor = 1.0f&#10;    private var postScaleWidthOffset = 0f&#10;    private var postScaleHeightOffset = 0f&#10;    private var needUpdateTransformation = true&#10;&#10;    private var brushSize = 50f&#10;    private val brushPaint = Paint().apply {&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 3f&#10;    }&#10;&#10;    private var touchX = 50f&#10;    private var touchY = 50f&#10;    private var isBrushVisible = false&#10;&#10;    private var livePath: Path = Path()&#10;    private var pathPaint: Paint&#10;    private var originalBitmap: Bitmap? = null&#10;    private var imageBitmap: Bitmap? = null&#10;    private val actionHistory = Stack&lt;Bitmap&gt;()&#10;    private val redoHistory = Stack&lt;Bitmap&gt;()&#10;    private var pathX = 0f&#10;    private var pathY = 0f&#10;    private var undoButton: ImageView? = null&#10;    private var redoButton: ImageView? = null&#10;    private var currentAction: DrawViewAction = DrawViewAction.ERASE_BACKGROUND&#10;    private var isDrawing = false&#10;&#10;    // Transformation state for TRANSFORM action&#10;    private var userMatrix = Matrix()&#10;    private var inverseUserMatrix = Matrix()&#10;    private var savedUserMatrix = Matrix()&#10;    private var modeTransform = TRANSFORM_NONE&#10;    private var startX = 0f&#10;    private var startY = 0f&#10;    private var midX = 0f&#10;    private var midY = 0f&#10;    private var oldDist = 1f&#10;    private var lastAngle = 0f&#10;    private var brushOffset = 0f // Default offset&#10;    private var brushActualX = 0f // Actual touch position&#10;    private var brushActualY = 0f // Actual touch position&#10;    private val MIN_USER_SCALE = 0.3f&#10;    private val MAX_USER_SCALE = 5.0f&#10;&#10;    init {&#10;        pathPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;            isDither = true&#10;            style = Paint.Style.STROKE&#10;            strokeJoin = Paint.Join.ROUND&#10;            strokeCap = Paint.Cap.ROUND&#10;            strokeWidth = brushSize&#10;        }&#10;        setAction(DrawViewAction.ERASE_BACKGROUND)&#10;    }&#10;&#10;    fun getBrushSize(): Float = brushSize&#10;&#10;    fun getCurrentAction(): DrawViewAction = currentAction&#10;&#10;    fun setBrushOffset(offset: Float) {&#10;        brushOffset = offset&#10;        invalidate()&#10;    }&#10;&#10;    fun getBrushOffset(): Float = brushOffset&#10;&#10;    fun setBrushSize(size: Float) {&#10;        brushSize = size&#10;        pathPaint.strokeWidth = size&#10;        invalidate()&#10;    }&#10;&#10;    fun showBrush() {&#10;        isBrushVisible = true&#10;        invalidate()&#10;    }&#10;&#10;    fun hideBrush() {&#10;        isBrushVisible = false&#10;        invalidate()&#10;    }&#10;&#10;    fun setAction(action: DrawViewAction) {&#10;        isDrawing = false&#10;        livePath.reset()&#10;        currentAction = action&#10;        when (action) {&#10;            DrawViewAction.ERASE_BACKGROUND -&gt; {&#10;                pathPaint.xfermode = PorterDuffXfermode(PorterDuff.Mode.CLEAR)&#10;                pathPaint.color = Color.TRANSPARENT&#10;                showBrush()&#10;            }&#10;            DrawViewAction.RECOVER_AREA -&gt; {&#10;                pathPaint.xfermode = null&#10;                pathPaint.color = Color.WHITE // Placeholder for recovery&#10;                showBrush()&#10;            }&#10;            DrawViewAction.NONE -&gt; {&#10;                pathPaint.xfermode = null&#10;                hideBrush()&#10;            }&#10;            DrawViewAction.TRANSFORM -&gt; {&#10;                // Hide brush when transforming&#10;                pathPaint.xfermode = null&#10;                hideBrush()&#10;                // Ensure matrices are ready&#10;                userMatrix = Matrix()&#10;                inverseUserMatrix = Matrix()&#10;                savedUserMatrix = Matrix()&#10;                modeTransform = TRANSFORM_NONE&#10;            }&#10;        }&#10;        updateBrushIndicator()&#10;    }&#10;&#10;    private fun updateBrushIndicator() {&#10;        brushPaint.color = when (currentAction) {&#10;            DrawViewAction.ERASE_BACKGROUND -&gt; Color.BLUE&#10;            DrawViewAction.RECOVER_AREA -&gt; Color.GREEN&#10;            DrawViewAction.NONE -&gt; Color.GRAY&#10;            DrawViewAction.TRANSFORM -&gt; Color.GRAY&#10;            else -&gt; Color.GRAY&#10;        }&#10;    }&#10;&#10;    fun setBitmap(bitmap: Bitmap?) {&#10;        if (bitmap != null) {&#10;            val convertedBitmap = if (bitmap.config == Bitmap.Config.HARDWARE) {&#10;                bitmap.copy(Bitmap.Config.ARGB_8888, true)&#10;            } else {&#10;                bitmap.copy(Bitmap.Config.ARGB_8888, true)&#10;            }&#10;&#10;            originalBitmap = convertedBitmap.copy(Bitmap.Config.ARGB_8888, false)&#10;            imageBitmap = convertedBitmap&#10;            imageWidth = imageBitmap!!.width&#10;            imageHeight = imageBitmap!!.height&#10;            needUpdateTransformation = true&#10;&#10;            actionHistory.clear()&#10;            redoHistory.clear()&#10;            updateButtonStates()&#10;&#10;            invalidate()&#10;        } else {&#10;            originalBitmap = null&#10;            imageBitmap = null&#10;            invalidate()&#10;            constrainUserMatrix()&#10;        }&#10;    }&#10;&#10;    fun getCurrentBitmap(): Bitmap? = imageBitmap&#10;&#10;    fun setButtons(undoButton: ImageView?, redoButton: ImageView?) {&#10;        this.undoButton = undoButton&#10;        this.redoButton = redoButton&#10;        updateButtonStates()&#10;    }&#10;&#10;    private fun updateButtonStates() {&#10;        undoButton?.isEnabled = actionHistory.isNotEmpty()&#10;        redoButton?.isEnabled = redoHistory.isNotEmpty()&#10;    }&#10;&#10;    fun undo() {&#10;        if (actionHistory.isNotEmpty() &amp;&amp; imageBitmap != null) {&#10;            redoHistory.push(imageBitmap!!.copy(Bitmap.Config.ARGB_8888, false))&#10;            val previousState = actionHistory.pop()&#10;            imageBitmap = previousState.copy(Bitmap.Config.ARGB_8888, true)&#10;            updateButtonStates()&#10;            invalidate()&#10;        }&#10;    }&#10;&#10;    fun redo() {&#10;        if (redoHistory.isNotEmpty() &amp;&amp; imageBitmap != null) {&#10;            actionHistory.push(imageBitmap!!.copy(Bitmap.Config.ARGB_8888, false))&#10;            val nextState = redoHistory.pop()&#10;            imageBitmap = nextState.copy(Bitmap.Config.ARGB_8888, true)&#10;            updateButtonStates()&#10;            invalidate()&#10;        }&#10;    }&#10;&#10;    private fun saveStateToHistory() {&#10;        imageBitmap?.let { bitmap -&gt;&#10;            actionHistory.push(bitmap.copy(Bitmap.Config.ARGB_8888, false))&#10;            redoHistory.clear()&#10;            updateButtonStates()&#10;        }&#10;    }&#10;&#10;    private fun updateTransformationIfNeeded() {&#10;        if (!needUpdateTransformation || imageWidth &lt;= 0 || imageHeight &lt;= 0) return&#10;&#10;        val viewWidth = width.toFloat()&#10;        val viewHeight = height.toFloat()&#10;        val viewAspectRatio = viewWidth / viewHeight&#10;        val imageAspectRatio = imageWidth.toFloat() / imageHeight&#10;&#10;        transformationMatrix.reset()&#10;&#10;        if (viewAspectRatio &gt; imageAspectRatio) {&#10;            scaleFactor = viewHeight / imageHeight&#10;            val scaledWidth = imageWidth * scaleFactor&#10;            postScaleWidthOffset = (viewWidth - scaledWidth) / 2&#10;            postScaleHeightOffset = 0f&#10;            transformationMatrix.setScale(scaleFactor, scaleFactor)&#10;            transformationMatrix.postTranslate(postScaleWidthOffset, 0f)&#10;        } else {&#10;            scaleFactor = viewWidth / imageWidth&#10;            val scaledHeight = imageHeight * scaleFactor&#10;            postScaleWidthOffset = 0f&#10;            postScaleHeightOffset = (viewHeight - scaledHeight) / 2&#10;            transformationMatrix.setScale(scaleFactor, scaleFactor)&#10;            transformationMatrix.postTranslate(0f, postScaleHeightOffset)&#10;        }&#10;&#10;        needUpdateTransformation = false&#10;        // Ensure userMatrix keeps the image visible after base transform changes&#10;        constrainUserMatrix()&#10;    }&#10;&#10;    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {&#10;        super.onSizeChanged(w, h, oldw, oldh)&#10;        if (touchX == 50f &amp;&amp; touchY == 50f) {  // Only if still at default position&#10;            touchX = w * 0.8f&#10;            touchY = h * 0.8f&#10;            invalidate()&#10;        }&#10;&#10;    }&#10;&#10;    @SuppressLint(&quot;DrawAllocation&quot;)&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;        updateTransformationIfNeeded()&#10;        canvas.save()&#10;&#10;        // Apply base transformation (scale to fit)&#10;        canvas.concat(transformationMatrix)&#10;&#10;        // Apply user transform on top (translate/scale/rotate) if any&#10;        canvas.concat(userMatrix)&#10;&#10;        imageBitmap?.let { bitmap -&gt;&#10;            if (isMemorySufficient(bitmap)) {&#10;                canvas.drawBitmap(bitmap, 0f, 0f, null)&#10;            }&#10;        }&#10;&#10;        canvas.restore()&#10;&#10;        if (isBrushVisible &amp;&amp; touchX &gt;= 0 &amp;&amp; touchY &gt;= 0) {&#10;            val offsetY = touchY - brushOffset&#10;&#10;            // Create fill paint with transparent color based on current action&#10;            val fillPaint = Paint().apply {&#10;                style = Paint.Style.FILL&#10;                when (currentAction) {&#10;                    DrawViewAction.ERASE_BACKGROUND -&gt; {&#10;                        color = Color.BLUE&#10;                        alpha = 60 // Transparent blue (about 25% opacity)&#10;                    }&#10;                    DrawViewAction.RECOVER_AREA -&gt; {&#10;                        color = Color.GREEN&#10;                        alpha = 60 // Transparent green (about 25% opacity)&#10;                    }&#10;                    DrawViewAction.NONE -&gt; {&#10;                        color = Color.GRAY&#10;                        alpha = 40 // Transparent gray&#10;                    }&#10;                    DrawViewAction.TRANSFORM -&gt; {&#10;                        color = Color.GRAY&#10;                        alpha = 40&#10;                    }&#10;                    else -&gt; {&#10;                        color = Color.GRAY&#10;                        alpha = 40&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Draw filled circle first (background)&#10;            canvas.drawCircle(touchX, offsetY, brushSize / 2, fillPaint)&#10;&#10;            // Draw stroke circle on top (border)&#10;            canvas.drawCircle(touchX, offsetY, brushSize / 2, brushPaint)&#10;&#10;            /*if (brushOffset &gt; 0) {&#10;                val linePaint = Paint().apply {&#10;                    color = brushPaint.color&#10;                    strokeWidth = 4f&#10;                    alpha = 100&#10;                }&#10;                canvas.drawLine(touchX, touchY, touchX, offsetY, linePaint)&#10;            }*/&#10;        }&#10;    }&#10;&#10;    init {&#10;        addOnLayoutChangeListener { _, _, _, _, _, _, _, _, _ -&gt;&#10;            needUpdateTransformation = true&#10;        }&#10;    }&#10;&#10;    private fun touchStart(x: Float, y: Float) {&#10;        if (currentAction == DrawViewAction.NONE) return&#10;&#10;&#10;        val imagePoint = screenToImageCoordinates(x, y)&#10;        if (imagePoint != null &amp;&amp; imagePoint[1] &gt;= 0) {&#10;            isDrawing = true&#10;            pathX = imagePoint[0]&#10;            pathY = imagePoint[1]&#10;            livePath.reset()&#10;            livePath.moveTo(pathX, pathY)&#10;            saveStateToHistory()&#10;        }&#10;    }&#10;&#10;    private fun touchMove(x: Float, y: Float) {&#10;        if (currentAction == DrawViewAction.NONE || !isDrawing) return&#10;&#10;        val imagePoint = screenToImageCoordinates(x, y)&#10;        if (imagePoint != null) {&#10;            val newX = imagePoint[0]&#10;            val newY = imagePoint[1]&#10;            val dx = Math.abs(newX - pathX)&#10;            val dy = Math.abs(newY - pathY)&#10;            if (dx &gt;= TOUCH_TOLERANCE || dy &gt;= TOUCH_TOLERANCE) {&#10;                livePath.quadTo(pathX, pathY, (newX + pathX) / 2, (newY + pathY) / 2)&#10;                pathX = newX&#10;                pathY = newY&#10;                applyPathToBitmap()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun touchUp() {&#10;        if (currentAction == DrawViewAction.NONE || !isDrawing) return&#10;&#10;        isDrawing = false&#10;        livePath.lineTo(pathX, pathY)&#10;        applyPathToBitmap()&#10;        livePath.reset()&#10;        invalidate()&#10;    }&#10;&#10;    private fun screenToImageCoordinates(screenX: Float, screenY: Float): FloatArray? {&#10;        if (imageBitmap == null) return null&#10;&#10;        val invertedMatrix = Matrix()&#10;        if (transformationMatrix.invert(invertedMatrix)) {&#10;            val point = floatArrayOf(screenX, screenY)&#10;            invertedMatrix.mapPoints(point)&#10;            if (point[0] &gt;= 0 &amp;&amp; point[0] &lt; imageWidth &amp;&amp; point[1] &gt;= 0 &amp;&amp; point[1] &lt; imageHeight) {&#10;                return point&#10;            }&#10;        }&#10;        return null&#10;    }&#10;&#10;    private fun applyPathToBitmap() {&#10;        imageBitmap?.let { bitmap -&gt;&#10;            if (currentAction == DrawViewAction.NONE) return&#10;&#10;            val canvas = Canvas(bitmap)&#10;            when (currentAction) {&#10;                DrawViewAction.ERASE_BACKGROUND -&gt; {&#10;                    canvas.drawPath(livePath, pathPaint)&#10;                }&#10;                DrawViewAction.RECOVER_AREA -&gt; {&#10;                    originalBitmap?.let { original -&gt;&#10;                        val maskBitmap = Bitmap.createBitmap(imageWidth, imageHeight, Bitmap.Config.ARGB_8888)&#10;                        val maskCanvas = Canvas(maskBitmap)&#10;                        maskCanvas.drawPath(livePath, Paint().apply {&#10;                            color = Color.WHITE&#10;                            style = Paint.Style.STROKE&#10;                            strokeWidth = brushSize&#10;                            strokeCap = Paint.Cap.ROUND&#10;                            strokeJoin = Paint.Join.ROUND&#10;                            isAntiAlias = true&#10;                        })&#10;&#10;                        val tempBitmap = original.copy(Bitmap.Config.ARGB_8888, true)&#10;                        val tempCanvas = Canvas(tempBitmap)&#10;                        tempCanvas.drawBitmap(maskBitmap, 0f, 0f, Paint().apply {&#10;                            xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_IN)&#10;                        })&#10;&#10;                        canvas.drawBitmap(tempBitmap, 0f, 0f, Paint().apply {&#10;                            xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_OVER)&#10;                            isAntiAlias = true&#10;                        })&#10;&#10;                        maskBitmap.recycle()&#10;                        tempBitmap.recycle()&#10;                    }&#10;                }&#10;                DrawViewAction.NONE -&gt; return&#10;                DrawViewAction.TRANSFORM -&gt; return&#10;            }&#10;            invalidate()&#10;        }&#10;    }&#10;&#10;    override fun onTouchEvent(event: MotionEvent): Boolean {&#10;        if (imageBitmap == null) return super.onTouchEvent(event)&#10;&#10;        if (currentAction == DrawViewAction.TRANSFORM) {&#10;            when (event.actionMasked) {&#10;                MotionEvent.ACTION_DOWN -&gt; {&#10;                    savedUserMatrix.set(userMatrix)&#10;                    startX = event.x&#10;                    startY = event.y&#10;                    modeTransform = TRANSFORM_DRAG&#10;                }&#10;                MotionEvent.ACTION_POINTER_DOWN -&gt; {&#10;                    oldDist = spacing(event)&#10;                    if (oldDist &gt; 10f) {&#10;                        savedUserMatrix.set(userMatrix)&#10;                        midPoint(event)&#10;                        lastAngle = rotation(event)&#10;                        modeTransform = TRANSFORM_ZOOM&#10;                    }&#10;                }&#10;                MotionEvent.ACTION_MOVE -&gt; {&#10;                    if (modeTransform == TRANSFORM_DRAG) {&#10;                        val dx = event.x - startX&#10;                        val dy = event.y - startY&#10;                        userMatrix.set(savedUserMatrix)&#10;                        userMatrix.postTranslate(dx / scaleFactor, dy / scaleFactor)&#10;                        constrainUserMatrix()&#10;                        invalidate()&#10;                    } else if (modeTransform == TRANSFORM_ZOOM &amp;&amp; event.pointerCount &gt;= 2) {&#10;                        val newDist = spacing(event)&#10;                        if (newDist &gt; 10f) {&#10;                            val scale = newDist / oldDist&#10;                            val newAngle = rotation(event)&#10;                            val angleDiff = newAngle - lastAngle&#10;&#10;                            // Clamp scale to min/max to avoid excessive zoom&#10;                            val baseScale = getMatrixScale(savedUserMatrix)&#10;                            var targetScale = baseScale * scale&#10;                            if (targetScale &lt; MIN_USER_SCALE) targetScale = MIN_USER_SCALE&#10;                            if (targetScale &gt; MAX_USER_SCALE) targetScale = MAX_USER_SCALE&#10;                            val adjustedScale = targetScale / baseScale&#10;&#10;                            userMatrix.set(savedUserMatrix)&#10;                            userMatrix.postScale(adjustedScale, adjustedScale, midX / scaleFactor, midY / scaleFactor)&#10;                            userMatrix.postRotate(angleDiff, midX / scaleFactor, midY / scaleFactor)&#10;                            constrainUserMatrix()&#10;                            invalidate()&#10;                        }&#10;                    }&#10;                }&#10;                MotionEvent.ACTION_POINTER_UP, MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#10;                    modeTransform = TRANSFORM_NONE&#10;                }&#10;            }&#10;            return true&#10;        }&#10;&#10;        // Fallback to drawing modes&#10;        if (currentAction == DrawViewAction.NONE) return super.onTouchEvent(event)&#10;&#10;        when (event.action) {&#10;            MotionEvent.ACTION_DOWN -&gt; {&#10;                // Store actual touch position&#10;                brushActualX = event.x&#10;                brushActualY = event.y&#10;&#10;                touchX = event.x&#10;                touchY = event.y&#10;&#10;                // Apply offset to drawing position&#10;                val drawingY = event.y - brushOffset&#10;                touchStart(event.x, drawingY)&#10;                invalidate()&#10;                return true&#10;            }&#10;            MotionEvent.ACTION_MOVE -&gt; {&#10;                // Store actual touch position&#10;                brushActualX = event.x&#10;                brushActualY = event.y&#10;&#10;                touchX = event.x&#10;                touchY = event.y&#10;&#10;                // Apply offset to drawing position&#10;                val drawingY = event.y - brushOffset&#10;                touchMove(event.x, drawingY)&#10;                invalidate()&#10;                return true&#10;            }&#10;            MotionEvent.ACTION_UP -&gt; {&#10;                touchUp()&#10;                return true&#10;            }&#10;        }&#10;        return super.onTouchEvent(event)&#10;    }&#10;&#10;    private fun spacing(event: MotionEvent): Float {&#10;        if (event.pointerCount &lt; 2) return 0f&#10;        val x = event.getX(0) - event.getX(1)&#10;        val y = event.getY(0) - event.getY(1)&#10;        return sqrt(x * x + y * y).toFloat()&#10;    }&#10;&#10;    private fun midPoint(event: MotionEvent) {&#10;        if (event.pointerCount &gt;= 2) {&#10;            midX = (event.getX(0) + event.getX(1)) / 2f&#10;            midY = (event.getY(0) + event.getY(1)) / 2f&#10;        }&#10;    }&#10;&#10;    private fun rotation(event: MotionEvent): Float {&#10;        if (event.pointerCount &gt;= 2) {&#10;            val deltaX = event.getX(0) - event.getX(1)&#10;            val deltaY = event.getY(0) - event.getY(1)&#10;            return Math.toDegrees(kotlin.math.atan2(deltaY, deltaX).toDouble()).toFloat()&#10;        }&#10;        return 0f&#10;    }&#10;&#10;    // Keep the userMatrix such that the transformed image remains visible inside the view bounds.&#10;    private fun constrainUserMatrix() {&#10;        if (imageBitmap == null || imageWidth &lt;= 0 || imageHeight &lt;= 0) return&#10;&#10;        // Compute combined matrix (base fit transform then user transform)&#10;        val combined = Matrix(transformationMatrix)&#10;        combined.postConcat(userMatrix)&#10;&#10;        val imageRect = android.graphics.RectF(0f, 0f, imageWidth.toFloat(), imageHeight.toFloat())&#10;        combined.mapRect(imageRect)&#10;&#10;        val viewW = width.toFloat()&#10;        val viewH = height.toFloat()&#10;&#10;        var deltaX = 0f&#10;        var deltaY = 0f&#10;&#10;        // Horizontal constraint&#10;        if (imageRect.width() &lt;= viewW) {&#10;            // center horizontally&#10;            deltaX = viewW / 2f - (imageRect.left + imageRect.right) / 2f&#10;        } else {&#10;            if (imageRect.left &gt; 0f) deltaX = -imageRect.left&#10;            if (imageRect.right &lt; viewW) deltaX = viewW - imageRect.right&#10;        }&#10;&#10;        // Vertical constraint&#10;        if (imageRect.height() &lt;= viewH) {&#10;            // center vertically&#10;            deltaY = viewH / 2f - (imageRect.top + imageRect.bottom) / 2f&#10;        } else {&#10;            if (imageRect.top &gt; 0f) deltaY = -imageRect.top&#10;            if (imageRect.bottom &lt; viewH) deltaY = viewH - imageRect.bottom&#10;        }&#10;&#10;        if (deltaX == 0f &amp;&amp; deltaY == 0f) return&#10;&#10;        // Build a translation matrix in view-space&#10;        val tView = Matrix().apply { setTranslate(deltaX, deltaY) }&#10;&#10;        // Compute T_user = inv(base) * T_view * base&#10;        val invBase = Matrix()&#10;        if (!transformationMatrix.invert(invBase)) return&#10;&#10;        val tUser = Matrix(invBase)&#10;        tUser.postConcat(tView)&#10;        tUser.postConcat(transformationMatrix)&#10;&#10;        // Pre-concatenate tUser so final combined = base * (tUser * userMatrix) == base * userMatrix translated in view-space&#10;        userMatrix.preConcat(tUser)&#10;    }&#10;&#10;    private fun getMatrixScale(matrix: Matrix): Float {&#10;        // Extract scale from matrix: sqrt(scaleX^2 + skewX^2)&#10;        val vals = FloatArray(9)&#10;        matrix.getValues(vals)&#10;        val scaleX = vals[Matrix.MSCALE_X]&#10;        val skewY = vals[Matrix.MSKEW_Y]&#10;        return kotlin.math.sqrt((scaleX * scaleX + skewY * skewY).toDouble()).toFloat()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ots.aipassportphotomaker.common.utils&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.Canvas&#10;import android.graphics.Color&#10;import android.graphics.Matrix&#10;import android.graphics.Paint&#10;import android.graphics.Path&#10;import android.graphics.PorterDuff&#10;import android.graphics.PorterDuffXfermode&#10;import android.util.AttributeSet&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.widget.ImageView&#10;import com.ots.aipassportphotomaker.common.utils.BitmapUtils.isMemorySufficient&#10;import java.util.Stack&#10;import kotlin.math.atan2&#10;import kotlin.math.sqrt&#10;&#10;// Transformation mode constants&#10;private const val TRANSFORM_NONE = 0&#10;private const val TRANSFORM_DRAG = 1&#10;private const val TRANSFORM_ZOOM = 2&#10;private const val TOUCH_TOLERANCE = 4f&#10;&#10;/**&#10; * Created by Aman Ullah&#10; * Sr. Software Engineer Android&#10; * Created on 13 Aug,2025 15:20&#10; * Copyright (c) All rights reserved.&#10; */&#10;&#10;&#10;/**&#10; * A view which renders a series of custom graphics to be overlayed on top of an associated preview&#10; * (i.e., the camera preview). The creator can add graphics objects, update the objects, and remove&#10; * them, triggering the appropriate drawing and invalidation within the view.&#10; *&#10; *&#10; * Supports scaling and mirroring of the graphics relative the camera's preview properties. The&#10; * idea is that detection items are expressed in terms of an image size, but need to be scaled up&#10; * to the full view size, and also mirrored in the case of the front-facing camera.&#10; *&#10; *&#10; * Associated [Graphic] items should use the following methods to convert to view&#10; * coordinates for the graphics that are drawn:&#10; *&#10; *&#10; *  1. [Graphic.scale] adjusts the size of the supplied value from the image scale&#10; * to the view scale.&#10; *  1. [Graphic.translateX] and [Graphic.translateY] adjust the&#10; * coordinate from the image's coordinate system to the view coordinate system.&#10; *&#10; */&#10;&#10;&#10;open class GraphicOverlay(context: Context?, attrs: AttributeSet?) : View(context, attrs) {&#10;&#10;    private val TAG = GraphicOverlay::class.java.simpleName&#10;&#10;    private val transformationMatrix = Matrix()&#10;    var imageWidth = 0&#10;        private set&#10;    var imageHeight = 0&#10;        private set&#10;&#10;    private var scaleFactor = 1.0f&#10;    private var postScaleWidthOffset = 0f&#10;    private var postScaleHeightOffset = 0f&#10;    private var needUpdateTransformation = true&#10;&#10;    private var brushSize = 50f&#10;    private val brushPaint = Paint().apply {&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 3f&#10;    }&#10;&#10;    private var touchX = 50f&#10;    private var touchY = 50f&#10;    private var isBrushVisible = false&#10;&#10;    private var livePath: Path = Path()&#10;    private var pathPaint: Paint&#10;    private var originalBitmap: Bitmap? = null&#10;    private var imageBitmap: Bitmap? = null&#10;    private val actionHistory = Stack&lt;Bitmap&gt;()&#10;    private val redoHistory = Stack&lt;Bitmap&gt;()&#10;    private var pathX = 0f&#10;    private var pathY = 0f&#10;    private var undoButton: ImageView? = null&#10;    private var redoButton: ImageView? = null&#10;    private var currentAction: DrawViewAction = DrawViewAction.ERASE_BACKGROUND&#10;    private var isDrawing = false&#10;&#10;    // Transformation state for TRANSFORM action&#10;    private var userMatrix = Matrix()&#10;    private var inverseUserMatrix = Matrix()&#10;    private var savedUserMatrix = Matrix()&#10;    private var modeTransform = TRANSFORM_NONE&#10;    private var startX = 0f&#10;    private var startY = 0f&#10;    private var midX = 0f&#10;    private var midY = 0f&#10;    private var oldDist = 1f&#10;    private var lastAngle = 0f&#10;    private var brushOffset = 0f // Default offset&#10;    private var brushActualX = 0f // Actual touch position&#10;    private var brushActualY = 0f // Actual touch position&#10;    private val MIN_USER_SCALE = 0.3f&#10;    private val MAX_USER_SCALE = 5.0f&#10;&#10;    init {&#10;        pathPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;            isDither = true&#10;            style = Paint.Style.STROKE&#10;            strokeJoin = Paint.Join.ROUND&#10;            strokeCap = Paint.Cap.ROUND&#10;            strokeWidth = brushSize&#10;        }&#10;        setAction(DrawViewAction.ERASE_BACKGROUND)&#10;    }&#10;&#10;    fun getBrushSize(): Float = brushSize&#10;&#10;    fun getCurrentAction(): DrawViewAction = currentAction&#10;&#10;    fun setBrushOffset(offset: Float) {&#10;        brushOffset = offset&#10;        invalidate()&#10;    }&#10;&#10;    fun getBrushOffset(): Float = brushOffset&#10;&#10;    fun setBrushSize(size: Float) {&#10;        brushSize = size&#10;        pathPaint.strokeWidth = size&#10;        invalidate()&#10;    }&#10;&#10;    fun showBrush() {&#10;        isBrushVisible = true&#10;        invalidate()&#10;    }&#10;&#10;    fun hideBrush() {&#10;        isBrushVisible = false&#10;        invalidate()&#10;    }&#10;&#10;    fun setAction(action: DrawViewAction) {&#10;        isDrawing = false&#10;        livePath.reset()&#10;        currentAction = action&#10;        when (action) {&#10;            DrawViewAction.ERASE_BACKGROUND -&gt; {&#10;                pathPaint.xfermode = PorterDuffXfermode(PorterDuff.Mode.CLEAR)&#10;                pathPaint.color = Color.TRANSPARENT&#10;                showBrush()&#10;            }&#10;            DrawViewAction.RECOVER_AREA -&gt; {&#10;                pathPaint.xfermode = null&#10;                pathPaint.color = Color.WHITE // Placeholder for recovery&#10;                showBrush()&#10;            }&#10;            DrawViewAction.NONE -&gt; {&#10;                pathPaint.xfermode = null&#10;                hideBrush()&#10;            }&#10;            DrawViewAction.TRANSFORM -&gt; {&#10;                // Hide brush when transforming&#10;                pathPaint.xfermode = null&#10;                hideBrush()&#10;                // Ensure matrices are ready&#10;                userMatrix = Matrix()&#10;                inverseUserMatrix = Matrix()&#10;                savedUserMatrix = Matrix()&#10;                modeTransform = TRANSFORM_NONE&#10;            }&#10;        }&#10;        updateBrushIndicator()&#10;    }&#10;&#10;    private fun updateBrushIndicator() {&#10;        brushPaint.color = when (currentAction) {&#10;            DrawViewAction.ERASE_BACKGROUND -&gt; Color.BLUE&#10;            DrawViewAction.RECOVER_AREA -&gt; Color.GREEN&#10;            DrawViewAction.NONE -&gt; Color.GRAY&#10;            DrawViewAction.TRANSFORM -&gt; Color.GRAY&#10;            else -&gt; Color.GRAY&#10;        }&#10;    }&#10;&#10;    fun setBitmap(bitmap: Bitmap?) {&#10;        if (bitmap != null) {&#10;            val convertedBitmap = if (bitmap.config == Bitmap.Config.HARDWARE) {&#10;                bitmap.copy(Bitmap.Config.ARGB_8888, true)&#10;            } else {&#10;                bitmap.copy(Bitmap.Config.ARGB_8888, true)&#10;            }&#10;&#10;            originalBitmap = convertedBitmap.copy(Bitmap.Config.ARGB_8888, false)&#10;            imageBitmap = convertedBitmap&#10;            imageWidth = imageBitmap!!.width&#10;            imageHeight = imageBitmap!!.height&#10;            needUpdateTransformation = true&#10;&#10;            actionHistory.clear()&#10;            redoHistory.clear()&#10;            updateButtonStates()&#10;&#10;            invalidate()&#10;        } else {&#10;            originalBitmap = null&#10;            imageBitmap = null&#10;            invalidate()&#10;            constrainUserMatrix()&#10;        }&#10;    }&#10;&#10;    fun getCurrentBitmap(): Bitmap? = imageBitmap&#10;&#10;    fun setButtons(undoButton: ImageView?, redoButton: ImageView?) {&#10;        this.undoButton = undoButton&#10;        this.redoButton = redoButton&#10;        updateButtonStates()&#10;    }&#10;&#10;    private fun updateButtonStates() {&#10;        undoButton?.isEnabled = actionHistory.isNotEmpty()&#10;        redoButton?.isEnabled = redoHistory.isNotEmpty()&#10;    }&#10;&#10;    fun undo() {&#10;        if (actionHistory.isNotEmpty() &amp;&amp; imageBitmap != null) {&#10;            redoHistory.push(imageBitmap!!.copy(Bitmap.Config.ARGB_8888, false))&#10;            val previousState = actionHistory.pop()&#10;            imageBitmap = previousState.copy(Bitmap.Config.ARGB_8888, true)&#10;            updateButtonStates()&#10;            invalidate()&#10;        }&#10;    }&#10;&#10;    fun redo() {&#10;        if (redoHistory.isNotEmpty() &amp;&amp; imageBitmap != null) {&#10;            actionHistory.push(imageBitmap!!.copy(Bitmap.Config.ARGB_8888, false))&#10;            val nextState = redoHistory.pop()&#10;            imageBitmap = nextState.copy(Bitmap.Config.ARGB_8888, true)&#10;            updateButtonStates()&#10;            invalidate()&#10;        }&#10;    }&#10;&#10;    private fun saveStateToHistory() {&#10;        imageBitmap?.let { bitmap -&gt;&#10;            actionHistory.push(bitmap.copy(Bitmap.Config.ARGB_8888, false))&#10;            redoHistory.clear()&#10;            updateButtonStates()&#10;        }&#10;    }&#10;&#10;    private fun updateTransformationIfNeeded() {&#10;        if (!needUpdateTransformation || imageWidth &lt;= 0 || imageHeight &lt;= 0) return&#10;&#10;        val viewWidth = width.toFloat()&#10;        val viewHeight = height.toFloat()&#10;        val viewAspectRatio = viewWidth / viewHeight&#10;        val imageAspectRatio = imageWidth.toFloat() / imageHeight&#10;&#10;        transformationMatrix.reset()&#10;&#10;        if (viewAspectRatio &gt; imageAspectRatio) {&#10;            scaleFactor = viewHeight / imageHeight&#10;            val scaledWidth = imageWidth * scaleFactor&#10;            postScaleWidthOffset = (viewWidth - scaledWidth) / 2&#10;            postScaleHeightOffset = 0f&#10;            transformationMatrix.setScale(scaleFactor, scaleFactor)&#10;            transformationMatrix.postTranslate(postScaleWidthOffset, 0f)&#10;        } else {&#10;            scaleFactor = viewWidth / imageWidth&#10;            val scaledHeight = imageHeight * scaleFactor&#10;            postScaleWidthOffset = 0f&#10;            postScaleHeightOffset = (viewHeight - scaledHeight) / 2&#10;            transformationMatrix.setScale(scaleFactor, scaleFactor)&#10;            transformationMatrix.postTranslate(0f, postScaleHeightOffset)&#10;        }&#10;&#10;        needUpdateTransformation = false&#10;        // Ensure userMatrix keeps the image visible after base transform changes&#10;        constrainUserMatrix()&#10;    }&#10;&#10;    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {&#10;        super.onSizeChanged(w, h, oldw, oldh)&#10;        if (touchX == 50f &amp;&amp; touchY == 50f) {  // Only if still at default position&#10;            touchX = w * 0.8f&#10;            touchY = h * 0.8f&#10;            invalidate()&#10;        }&#10;&#10;    }&#10;&#10;    @SuppressLint(&quot;DrawAllocation&quot;)&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;        updateTransformationIfNeeded()&#10;        canvas.save()&#10;&#10;        // Apply base transformation (scale to fit)&#10;        canvas.concat(transformationMatrix)&#10;&#10;        // Apply user transform on top (translate/scale/rotate) if any&#10;        canvas.concat(userMatrix)&#10;&#10;        imageBitmap?.let { bitmap -&gt;&#10;            if (isMemorySufficient(bitmap)) {&#10;                canvas.drawBitmap(bitmap, 0f, 0f, null)&#10;            }&#10;        }&#10;&#10;        canvas.restore()&#10;&#10;        if (isBrushVisible &amp;&amp; touchX &gt;= 0 &amp;&amp; touchY &gt;= 0) {&#10;            val offsetY = touchY - brushOffset&#10;&#10;            // Create fill paint with transparent color based on current action&#10;            val fillPaint = Paint().apply {&#10;                style = Paint.Style.FILL&#10;                when (currentAction) {&#10;                    DrawViewAction.ERASE_BACKGROUND -&gt; {&#10;                        color = Color.BLUE&#10;                        alpha = 60 // Transparent blue (about 25% opacity)&#10;                    }&#10;                    DrawViewAction.RECOVER_AREA -&gt; {&#10;                        color = Color.GREEN&#10;                        alpha = 60 // Transparent green (about 25% opacity)&#10;                    }&#10;                    DrawViewAction.NONE -&gt; {&#10;                        color = Color.GRAY&#10;                        alpha = 40 // Transparent gray&#10;                    }&#10;                    DrawViewAction.TRANSFORM -&gt; {&#10;                        color = Color.GRAY&#10;                        alpha = 40&#10;                    }&#10;                    else -&gt; {&#10;                        color = Color.GRAY&#10;                        alpha = 40&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Draw filled circle first (background)&#10;            canvas.drawCircle(touchX, offsetY, brushSize / 2, fillPaint)&#10;&#10;            // Draw stroke circle on top (border)&#10;            canvas.drawCircle(touchX, offsetY, brushSize / 2, brushPaint)&#10;&#10;            /*if (brushOffset &gt; 0) {&#10;                val linePaint = Paint().apply {&#10;                    color = brushPaint.color&#10;                    strokeWidth = 4f&#10;                    alpha = 100&#10;                }&#10;                canvas.drawLine(touchX, touchY, touchX, offsetY, linePaint)&#10;            }*/&#10;        }&#10;    }&#10;&#10;    init {&#10;        addOnLayoutChangeListener { _, _, _, _, _, _, _, _, _ -&gt;&#10;            needUpdateTransformation = true&#10;        }&#10;    }&#10;&#10;    private fun touchStart(x: Float, y: Float) {&#10;        if (currentAction == DrawViewAction.NONE) return&#10;&#10;&#10;        val imagePoint = screenToImageCoordinates(x, y)&#10;        if (imagePoint != null &amp;&amp; imagePoint[1] &gt;= 0) {&#10;            isDrawing = true&#10;            pathX = imagePoint[0]&#10;            pathY = imagePoint[1]&#10;            livePath.reset()&#10;            livePath.moveTo(pathX, pathY)&#10;            saveStateToHistory()&#10;        }&#10;    }&#10;&#10;    private fun touchMove(x: Float, y: Float) {&#10;        if (currentAction == DrawViewAction.NONE || !isDrawing) return&#10;&#10;        val imagePoint = screenToImageCoordinates(x, y)&#10;        if (imagePoint != null) {&#10;            val newX = imagePoint[0]&#10;            val newY = imagePoint[1]&#10;            val dx = Math.abs(newX - pathX)&#10;            val dy = Math.abs(newY - pathY)&#10;            if (dx &gt;= TOUCH_TOLERANCE || dy &gt;= TOUCH_TOLERANCE) {&#10;                livePath.quadTo(pathX, pathY, (newX + pathX) / 2, (newY + pathY) / 2)&#10;                pathX = newX&#10;                pathY = newY&#10;                applyPathToBitmap()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun touchUp() {&#10;        if (currentAction == DrawViewAction.NONE || !isDrawing) return&#10;&#10;        isDrawing = false&#10;        livePath.lineTo(pathX, pathY)&#10;        applyPathToBitmap()&#10;        livePath.reset()&#10;        invalidate()&#10;    }&#10;&#10;    private fun screenToImageCoordinates(screenX: Float, screenY: Float): FloatArray? {&#10;        if (imageBitmap == null) return null&#10;&#10;        val invertedMatrix = Matrix()&#10;        if (transformationMatrix.invert(invertedMatrix)) {&#10;            val point = floatArrayOf(screenX, screenY)&#10;            invertedMatrix.mapPoints(point)&#10;            if (point[0] &gt;= 0 &amp;&amp; point[0] &lt; imageWidth &amp;&amp; point[1] &gt;= 0 &amp;&amp; point[1] &lt; imageHeight) {&#10;                return point&#10;            }&#10;        }&#10;        return null&#10;    }&#10;&#10;    private fun applyPathToBitmap() {&#10;        imageBitmap?.let { bitmap -&gt;&#10;            if (currentAction == DrawViewAction.NONE) return&#10;&#10;            val canvas = Canvas(bitmap)&#10;            when (currentAction) {&#10;                DrawViewAction.ERASE_BACKGROUND -&gt; {&#10;                    canvas.drawPath(livePath, pathPaint)&#10;                }&#10;                DrawViewAction.RECOVER_AREA -&gt; {&#10;                    originalBitmap?.let { original -&gt;&#10;                        val maskBitmap = Bitmap.createBitmap(imageWidth, imageHeight, Bitmap.Config.ARGB_8888)&#10;                        val maskCanvas = Canvas(maskBitmap)&#10;                        maskCanvas.drawPath(livePath, Paint().apply {&#10;                            color = Color.WHITE&#10;                            style = Paint.Style.STROKE&#10;                            strokeWidth = brushSize&#10;                            strokeCap = Paint.Cap.ROUND&#10;                            strokeJoin = Paint.Join.ROUND&#10;                            isAntiAlias = true&#10;                        })&#10;&#10;                        val tempBitmap = original.copy(Bitmap.Config.ARGB_8888, true)&#10;                        val tempCanvas = Canvas(tempBitmap)&#10;                        tempCanvas.drawBitmap(maskBitmap, 0f, 0f, Paint().apply {&#10;                            xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_IN)&#10;                        })&#10;&#10;                        canvas.drawBitmap(tempBitmap, 0f, 0f, Paint().apply {&#10;                            xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_OVER)&#10;                            isAntiAlias = true&#10;                        })&#10;&#10;                        maskBitmap.recycle()&#10;                        tempBitmap.recycle()&#10;                    }&#10;                }&#10;                DrawViewAction.NONE -&gt; return&#10;                DrawViewAction.TRANSFORM -&gt; return&#10;            }&#10;            invalidate()&#10;        }&#10;    }&#10;&#10;    override fun onTouchEvent(event: MotionEvent): Boolean {&#10;        if (imageBitmap == null) return super.onTouchEvent(event)&#10;&#10;        if (currentAction == DrawViewAction.TRANSFORM) {&#10;            when (event.actionMasked) {&#10;                MotionEvent.ACTION_DOWN -&gt; {&#10;                    savedUserMatrix.set(userMatrix)&#10;                    startX = event.x&#10;                    startY = event.y&#10;                    modeTransform = TRANSFORM_DRAG&#10;                }&#10;                MotionEvent.ACTION_POINTER_DOWN -&gt; {&#10;                    oldDist = spacing(event)&#10;                    if (oldDist &gt; 10f) {&#10;                        savedUserMatrix.set(userMatrix)&#10;                        midPoint(event)&#10;                        lastAngle = rotation(event)&#10;                        modeTransform = TRANSFORM_ZOOM&#10;                    }&#10;                }&#10;                MotionEvent.ACTION_MOVE -&gt; {&#10;                    if (modeTransform == TRANSFORM_DRAG) {&#10;                        val dx = event.x - startX&#10;                        val dy = event.y - startY&#10;                        userMatrix.set(savedUserMatrix)&#10;                        userMatrix.postTranslate(dx / scaleFactor, dy / scaleFactor)&#10;                        constrainUserMatrix()&#10;                        invalidate()&#10;                    } else if (modeTransform == TRANSFORM_ZOOM &amp;&amp; event.pointerCount &gt;= 2) {&#10;                        val newDist = spacing(event)&#10;                        if (newDist &gt; 10f) {&#10;                            val scale = newDist / oldDist&#10;                            val newAngle = rotation(event)&#10;                            val angleDiff = newAngle - lastAngle&#10;&#10;                            // Clamp scale to min/max to avoid excessive zoom&#10;                            val baseScale = getMatrixScale(savedUserMatrix)&#10;                            var targetScale = baseScale * scale&#10;                            if (targetScale &lt; MIN_USER_SCALE) targetScale = MIN_USER_SCALE&#10;                            if (targetScale &gt; MAX_USER_SCALE) targetScale = MAX_USER_SCALE&#10;                            val adjustedScale = targetScale / baseScale&#10;&#10;                            userMatrix.set(savedUserMatrix)&#10;                            userMatrix.postScale(adjustedScale, adjustedScale, midX / scaleFactor, midY / scaleFactor)&#10;                            userMatrix.postRotate(angleDiff, midX / scaleFactor, midY / scaleFactor)&#10;                            constrainUserMatrix()&#10;                            invalidate()&#10;                        }&#10;                    }&#10;                }&#10;                MotionEvent.ACTION_POINTER_UP, MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#10;                    modeTransform = TRANSFORM_NONE&#10;                }&#10;            }&#10;            return true&#10;        }&#10;&#10;        // Fallback to drawing modes&#10;        if (currentAction == DrawViewAction.NONE) return super.onTouchEvent(event)&#10;&#10;        when (event.action) {&#10;            MotionEvent.ACTION_DOWN -&gt; {&#10;                // Store actual touch position&#10;                brushActualX = event.x&#10;                brushActualY = event.y&#10;&#10;                touchX = event.x&#10;                touchY = event.y&#10;&#10;                // Apply offset to drawing position&#10;                val drawingY = event.y - brushOffset&#10;                touchStart(event.x, drawingY)&#10;                invalidate()&#10;                return true&#10;            }&#10;            MotionEvent.ACTION_MOVE -&gt; {&#10;                // Store actual touch position&#10;                brushActualX = event.x&#10;                brushActualY = event.y&#10;&#10;                touchX = event.x&#10;                touchY = event.y&#10;&#10;                // Apply offset to drawing position&#10;                val drawingY = event.y - brushOffset&#10;                touchMove(event.x, drawingY)&#10;                invalidate()&#10;                return true&#10;            }&#10;            MotionEvent.ACTION_UP -&gt; {&#10;                touchUp()&#10;                return true&#10;            }&#10;        }&#10;        return super.onTouchEvent(event)&#10;    }&#10;&#10;    private fun spacing(event: MotionEvent): Float {&#10;        if (event.pointerCount &lt; 2) return 0f&#10;        val x = event.getX(0) - event.getX(1)&#10;        val y = event.getY(0) - event.getY(1)&#10;        return sqrt(x * x + y * y).toFloat()&#10;    }&#10;&#10;    private fun midPoint(event: MotionEvent) {&#10;        if (event.pointerCount &gt;= 2) {&#10;            midX = (event.getX(0) + event.getX(1)) / 2f&#10;            midY = (event.getY(0) + event.getY(1)) / 2f&#10;        }&#10;    }&#10;&#10;    private fun rotation(event: MotionEvent): Float {&#10;        if (event.pointerCount &gt;= 2) {&#10;            val deltaX = event.getX(0) - event.getX(1)&#10;            val deltaY = event.getY(0) - event.getY(1)&#10;            return Math.toDegrees(kotlin.math.atan2(deltaY, deltaX).toDouble()).toFloat()&#10;        }&#10;        return 0f&#10;    }&#10;&#10;    // Keep the userMatrix such that the transformed image remains visible inside the view bounds.&#10;    private fun constrainUserMatrix() {&#10;        if (imageBitmap == null || imageWidth &lt;= 0 || imageHeight &lt;= 0) return&#10;&#10;        // Compute combined matrix (base fit transform then user transform)&#10;        val combined = Matrix(transformationMatrix)&#10;        combined.postConcat(userMatrix)&#10;&#10;        val imageRect = android.graphics.RectF(0f, 0f, imageWidth.toFloat(), imageHeight.toFloat())&#10;        combined.mapRect(imageRect)&#10;&#10;        val viewW = width.toFloat()&#10;        val viewH = height.toFloat()&#10;&#10;        var deltaX = 0f&#10;        var deltaY = 0f&#10;&#10;        // Horizontal constraint&#10;        if (imageRect.width() &lt;= viewW) {&#10;            // center horizontally&#10;            deltaX = viewW / 2f - (imageRect.left + imageRect.right) / 2f&#10;        } else {&#10;            if (imageRect.left &gt; 0f) deltaX = -imageRect.left&#10;            if (imageRect.right &lt; viewW) deltaX = viewW - imageRect.right&#10;        }&#10;&#10;        // Vertical constraint&#10;        if (imageRect.height() &lt;= viewH) {&#10;            // center vertically&#10;            deltaY = viewH / 2f - (imageRect.top + imageRect.bottom) / 2f&#10;        } else {&#10;            if (imageRect.top &gt; 0f) deltaY = -imageRect.top&#10;            if (imageRect.bottom &lt; viewH) deltaY = viewH - imageRect.bottom&#10;        }&#10;&#10;        if (deltaX == 0f &amp;&amp; deltaY == 0f) return&#10;&#10;        // Build a translation matrix in view-space&#10;        val tView = Matrix().apply { setTranslate(deltaX, deltaY) }&#10;&#10;        // Compute T_user = inv(base) * T_view * base&#10;        val invBase = Matrix()&#10;        if (!transformationMatrix.invert(invBase)) return&#10;&#10;        val tUser = Matrix(invBase)&#10;        tUser.postConcat(tView)&#10;        tUser.postConcat(transformationMatrix)&#10;&#10;        // Pre-concatenate tUser so final combined = base * (tUser * userMatrix) == base * userMatrix translated in view-space&#10;        userMatrix.preConcat(tUser)&#10;    }&#10;&#10;    private fun getMatrixScale(matrix: Matrix): Float {&#10;        // Extract scale from matrix: sqrt(scaleX^2 + skewX^2)&#10;        val vals = FloatArray(9)&#10;        matrix.getValues(vals)&#10;        val scaleX = vals[Matrix.MSCALE_X]&#10;        val skewY = vals[Matrix.MSKEW_Y]&#10;        return kotlin.math.sqrt((scaleX * scaleX + skewY * skewY).toDouble()).toFloat()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ots/aipassportphotomaker/presentation/ui/cutout/CutOutImageScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ots/aipassportphotomaker/presentation/ui/cutout/CutOutImageScreen.kt" />
              <option name="originalContent" value="package com.ots.aipassportphotomaker.presentation.ui.cutout&#10;&#10;import android.annotation.SuppressLint&#10;import android.graphics.Bitmap&#10;import android.graphics.Canvas&#10;import android.graphics.drawable.BitmapDrawable&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectTapGestures&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.asPaddingValues&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.heightIn&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.systemBars&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.layout.wrapContentSize&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Slider&#10;import androidx.compose.material3.SliderDefaults&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableFloatStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.produceState&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.ImageBitmap&#10;import androidx.compose.ui.graphics.asAndroidBitmap&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.core.graphics.createBitmap&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import coil.ImageLoader&#10;import coil.request.ImageRequest&#10;import com.airbnb.lottie.compose.LottieAnimation&#10;import com.airbnb.lottie.compose.LottieCompositionSpec&#10;import com.airbnb.lottie.compose.LottieConstants&#10;import com.airbnb.lottie.compose.rememberLottieComposition&#10;import com.google.android.gms.ads.AdSize&#10;import com.ots.aipassportphotomaker.R&#10;import com.ots.aipassportphotomaker.adsmanager.admob.AdMobBanner&#10;import com.ots.aipassportphotomaker.adsmanager.admob.AdaptiveBannerAd&#10;import com.ots.aipassportphotomaker.adsmanager.admob.adids.AdIdsFactory&#10;import com.ots.aipassportphotomaker.common.ext.animatedBorder&#10;import com.ots.aipassportphotomaker.common.ext.collectAsEffect&#10;import com.ots.aipassportphotomaker.common.preview.PreviewContainer&#10;import com.ots.aipassportphotomaker.common.utils.AnalyticsConstants&#10;import com.ots.aipassportphotomaker.common.utils.DrawViewAction&#10;import com.ots.aipassportphotomaker.common.utils.FileUtils.saveBitmapToInternalStorage&#10;import com.ots.aipassportphotomaker.common.utils.GraphicOverlay&#10;import com.ots.aipassportphotomaker.common.utils.ImageUtils.saveBitmapToGallery&#10;import com.ots.aipassportphotomaker.common.utils.Logger&#10;import com.ots.aipassportphotomaker.domain.model.ProcessingStage&#10;import com.ots.aipassportphotomaker.presentation.ui.bottom_nav.NavigationBarSharedViewModel&#10;import com.ots.aipassportphotomaker.presentation.ui.components.CommonTopBar&#10;import com.ots.aipassportphotomaker.presentation.ui.components.CustomTab&#10;import com.ots.aipassportphotomaker.presentation.ui.components.LoaderFullScreen&#10;import com.ots.aipassportphotomaker.presentation.ui.main.MainRouter&#10;import com.ots.aipassportphotomaker.presentation.ui.theme.colors&#10;import com.ots.aipassportphotomaker.presentation.ui.theme.custom300&#10;import com.ots.aipassportphotomaker.presentation.viewmodel.SharedViewModel&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.io.File&#10;import android.graphics.Color as AndroidColor&#10;&#10;// Created by amanullah on 04/09/2025.&#10;// Copyright (c) 2025 Ozi Publishing. All rights reserved.&#10;&#10;@Composable&#10;fun CutOutImagePage(&#10;    mainRouter: MainRouter,&#10;    viewModel: CutOutImageScreenViewModel = hiltViewModel(),&#10;    sharedViewModel: NavigationBarSharedViewModel&#10;) {&#10;    val TAG = &quot;CutOutImagePage&quot;&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val context = LocalContext.current&#10;    val activity = context as ComponentActivity&#10;    val uiScope = rememberCoroutineScope()&#10;&#10;    val imageUrl = viewModel.imageUrl&#10;    val selectedColor = viewModel.selectedColor&#10;&#10;    viewModel.navigationState.collectAsEffect { navigationState -&gt;&#10;&#10;        Log.d(TAG, &quot;CutOutImagePage: Navigation State: $navigationState, ImageUrl: $imageUrl&quot;)&#10;        when (navigationState) {&#10;            is CutOutImageScreenNavigationState.SavedImageScreen -&gt; mainRouter.navigateFromCutoutToSavedImageScreen(&#10;                documentId = navigationState.documentId,&#10;                imagePath = uiState.imageUrl,&#10;                sourceScreen = &quot;CutOutImageScreen&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    val processingStage by viewModel.processingStage.collectAsState()&#10;&#10;    val commonSharedViewModel: SharedViewModel = hiltViewModel(activity)&#10;&#10;    CutOutImageScreen(&#10;        uiState = uiState,&#10;        processingStage = processingStage,&#10;        selectedColor = selectedColor,&#10;        isPremium = viewModel.isPremiumUser(),&#10;        onBackClick = {&#10;            viewModel.sendEvent(AnalyticsConstants.CLICKED, &quot;btnBack_CutOutImageScreen&quot;)&#10;            mainRouter.goBack()&#10;&#10;            viewModel.showInterstitialAd(activity) { }&#10;        },&#10;        onGetProClick = {&#10;            viewModel.sendEvent(AnalyticsConstants.CLICKED, &quot;btnGetPro_CutOutImageScreen&quot;)&#10;            mainRouter.navigateToPremiumScreen()&#10;        },&#10;        onSaveImage = { bitmap -&gt;&#10;            viewModel.sendEvent(AnalyticsConstants.CLICKED, &quot;btnSave_CutOutImageScreen&quot;)&#10;            uiScope.launch {&#10;                when (viewModel.sourceScreen) {&#10;                    &quot;EditImageScreen&quot; -&gt; {&#10;                        Logger.i(TAG, &quot;onSaveImage: Navigating back to EditImageScreen&quot;)&#10;                        val internalPath =&#10;                            saveBitmapToInternalStorage(context, bitmap.asAndroidBitmap())&#10;                        if (internalPath != null) {&#10;                            Logger.i(TAG, &quot;Image saved successfully: $internalPath&quot;)&#10;                            commonSharedViewModel.setEditedImageResult(internalPath)&#10;&#10;                            delay(100)&#10;                            mainRouter.goBack()&#10;&#10;                            viewModel.showInterstitialAd(activity) { }&#10;&#10;                        } else {&#10;                            Logger.e(TAG, &quot;Failed to save image&quot;)&#10;                        }&#10;                    }&#10;&#10;                    &quot;HomeScreen&quot; -&gt; {&#10;                        Logger.i(TAG, &quot;onSaveImage: Navigating to final screen&quot;)&#10;                        val savedUri = saveBitmapToGallery(context, bitmap.asAndroidBitmap())&#10;                        if (savedUri != null) {&#10;&#10;                            viewModel.onImageSaved(savedUri.toString())&#10;                            viewModel.showInterstitialAd(activity) { }&#10;&#10;                            /*viewModel.loadAndShowRewardedAd(&#10;                                activity,&#10;                                onAdClosed = {&#10;                                    viewModel.onImageSaved(savedUri.toString())&#10;                                },&#10;                                onRewardedEarned = { isEarned -&gt;&#10;                                    if (!isEarned) {&#10;                                        viewModel.onImageSaved(savedUri.toString())&#10;                                        viewModel.showInterstitialAd(activity) { }&#10;                                    }&#10;&#10;                                })*/&#10;&#10;                            Logger.i(TAG, &quot;Image saved successfully: $savedUri&quot;)&#10;&#10;                        } else {&#10;                            Logger.e(TAG, &quot;Failed to save image&quot;)&#10;                        }&#10;                    }&#10;&#10;                    else -&gt; {&#10;                        Logger.i(&#10;                            TAG,&#10;                            &quot;onSaveImage: Unknown sourceScreen, defaulting to EditImageScreen: ${uiState.sourceScreen}&quot;&#10;                        )&#10;                        val savedUri = saveBitmapToGallery(context, bitmap.asAndroidBitmap())&#10;                        if (savedUri != null) {&#10;                            Logger.i(TAG, &quot;Image saved successfully: $savedUri&quot;)&#10;                            commonSharedViewModel.setEditedImageResult(savedUri.toString())&#10;&#10;                            delay(100)&#10;                            mainRouter.goBack()&#10;&#10;                        } else {&#10;                            Logger.e(TAG, &quot;Failed to save image&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        onRemoveBackgroundAi = { bitmap -&gt;&#10;            uiScope.launch {&#10;                val internalPath = saveBitmapToInternalStorage(context, bitmap.asAndroidBitmap())&#10;                if (internalPath != null) {&#10;                    Logger.i(TAG, &quot;Image saved successfully: $internalPath&quot;)&#10;                    viewModel.removeBackground(File(internalPath))&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    BackHandler {&#10;        viewModel.sendEvent(AnalyticsConstants.CLICKED, &quot;backPress_CutOutImageScreen&quot;)&#10;        mainRouter.goBack()&#10;        viewModel.showInterstitialAd(activity) { }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@SuppressLint(&quot;UseKtx&quot;)&#10;@Composable&#10;private fun CutOutImageScreen(&#10;    uiState: CutOutImageScreenUiState,&#10;    processingStage: ProcessingStage = ProcessingStage.NONE,&#10;    selectedColor: String? = null,&#10;    isPremium: Boolean,&#10;    onSaveImage: (ImageBitmap) -&gt; Unit = {},&#10;    onRemoveBackgroundAi: (ImageBitmap) -&gt; Unit = {},&#10;    onBackClick: () -&gt; Unit = {},&#10;    onGetProClick: () -&gt; Unit = {},&#10;) {&#10;    val composition by rememberLottieComposition(LottieCompositionSpec.RawRes(R.raw.ai_erase))&#10;    val systemBarsPadding = WindowInsets.systemBars.asPaddingValues()&#10;&#10;    val TAG = &quot;CutOutImageScreen&quot;&#10;    Surface(&#10;        modifier = Modifier&#10;            .padding(bottom = systemBarsPadding.calculateBottomPadding())&#10;    ) {&#10;&#10;        val context = LocalContext.current&#10;        val isLoading = uiState.showLoading&#10;        val errorMessage = uiState.errorMessage&#10;        val backgroundColor = uiState.selectedColor&#10;        val imageUrl = uiState.imageUrl&#10;&#10;        val uiScope = rememberCoroutineScope()&#10;&#10;        var graphicOverlay by remember { mutableStateOf&lt;GraphicOverlay?&gt;(null) }&#10;        var currentMode by remember { mutableStateOf(DrawViewAction.ERASE_BACKGROUND) }&#10;        var brushSize by remember { mutableFloatStateOf(50f) }&#10;        var brushOffset by remember { mutableFloatStateOf(0f) }&#10;        var finalBitmap: ImageBitmap? by remember { mutableStateOf(null) }&#10;        var removeBackgroundBitmap: ImageBitmap? by remember { mutableStateOf(null) }&#10;        val (selected, setSelected) = remember { mutableStateOf(1) }&#10;&#10;        Logger.i(&#10;            &quot;CutOutImagePage&quot;,&#10;            &quot;Rendering with imageUrl: $imageUrl, isLoading: $isLoading, errorMessage: $errorMessage&quot;&#10;        )&#10;&#10;        if (errorMessage != null) Toast.makeText(context, errorMessage, Toast.LENGTH_SHORT).show()&#10;&#10;        Column(&#10;            modifier = Modifier&#10;                .background(colors.background)&#10;                .fillMaxWidth()&#10;                .pointerInput(Unit) {&#10;                    detectTapGestures(&#10;                        onTap = {&#10;&#10;                        })&#10;                }&#10;        ) {&#10;            CommonTopBar(&#10;                title = stringResource(id = R.string.cut_out),&#10;                showGetProButton = !isPremium,&#10;                onBackClick = {&#10;                    onBackClick.invoke()&#10;&#10;                },&#10;                onGetProClick = {&#10;                    onGetProClick.invoke()&#10;&#10;                }&#10;            )&#10;&#10;            if (isLoading) {&#10;                LoaderFullScreen()&#10;            } else {&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                ) {&#10;&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .background(colors.background)&#10;                            .fillMaxSize()&#10;                            .pointerInput(Unit) {&#10;                                detectTapGestures(&#10;                                    onTap = {&#10;&#10;                                    })&#10;                            }&#10;                    ) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .aspectRatio(1f)&#10;                                .background(Color.LightGray)&#10;                        ) {&#10;&#10;                            Image(&#10;                                painter = painterResource(id = R.drawable.transparent_bg),&#10;                                contentDescription = &quot;Transparent Background&quot;,&#10;                                modifier = Modifier&#10;                                    .matchParentSize(),&#10;                                contentScale = ContentScale.Crop&#10;                            )&#10;&#10;                            // Load the image as a bitmap&#10;                            val imageLoader = ImageLoader.Builder(context).build()&#10;                            var bitmap by remember { mutableStateOf&lt;Bitmap?&gt;(null) }&#10;&#10;                            LaunchedEffect(imageUrl) {&#10;                                if (!imageUrl.isNullOrEmpty()) {&#10;                                    try {&#10;                                        val imageLoader = ImageLoader.Builder(context).build()&#10;                                        val request = ImageRequest.Builder(context)&#10;                                            .data(imageUrl)&#10;                                            .target { drawable -&gt;&#10;                                                val newBitmap = when (drawable) {&#10;                                                    is BitmapDrawable -&gt; drawable.bitmap&#10;                                                    else -&gt; {&#10;                                                        val bmp = createBitmap(&#10;                                                            drawable.intrinsicWidth,&#10;                                                            drawable.intrinsicHeight,&#10;                                                            Bitmap.Config.ARGB_8888&#10;                                                        )&#10;                                                        val canvas = Canvas(bmp)&#10;                                                        drawable.setBounds(&#10;                                                            0,&#10;                                                            0,&#10;                                                            canvas.width,&#10;                                                            canvas.height&#10;                                                        )&#10;                                                        drawable.draw(canvas)&#10;                                                        bmp&#10;                                                    }&#10;                                                }&#10;&#10;                                                // Update both bitmap state and GraphicOverlay&#10;                                                bitmap = newBitmap&#10;                                                graphicOverlay?.setBitmap(newBitmap)&#10;&#10;                                                Logger.i(&#10;                                                    &quot;CutOutImageScreen&quot;,&#10;                                                    &quot;Image updated successfully: ${imageUrl}&quot;&#10;                                                )&#10;                                            }&#10;                                            .build()&#10;                                        imageLoader.enqueue(request)&#10;                                    } catch (e: Exception) {&#10;                                        Logger.e(&#10;                                            &quot;CutOutImageScreen&quot;,&#10;                                            &quot;Failed to load image: ${e.message}&quot;,&#10;                                            e&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            AndroidView(&#10;                                factory = { ctx -&gt;&#10;&#10;                                    GraphicOverlay(context, null).apply {&#10;                                        graphicOverlay = this&#10;                                    }&#10;                                },&#10;                                update = { view -&gt;&#10;                                    if (view.getCurrentBitmap() == null &amp;&amp; bitmap != null) {&#10;                                        view.setBitmap(bitmap)&#10;                                    }&#10;&#10;                                    // Only update brush size if it actually changed&#10;                                    if (view.getBrushSize() != brushSize) {&#10;                                        view.setBrushSize(brushSize)&#10;                                    }&#10;&#10;                                    // Update brush offset&#10;                                    if (view.getBrushOffset() != brushOffset) {&#10;                                        view.setBrushOffset(brushOffset)&#10;                                    }&#10;&#10;                                    // Only update action if it actually changed&#10;                                    if (view.getCurrentAction() != currentMode) {&#10;                                        view.setAction(currentMode)&#10;                                    }&#10;                                },&#10;                                modifier = Modifier&#10;                                    .padding(horizontal = 8.dp)&#10;                                    .matchParentSize()&#10;                            )&#10;                        }&#10;&#10;&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                    }&#10;&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .align(Alignment.BottomCenter)&#10;                    ) {&#10;&#10;&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .padding(end = 16.dp)&#10;                                .align(Alignment.End)&#10;                        ) {&#10;                            Icon(&#10;                                modifier = Modifier&#10;                                    .padding(6.dp)&#10;                                    .clickable(onClick = {&#10;                                        graphicOverlay?.undo()&#10;                                    }),&#10;                                painter = painterResource(id = R.drawable.undo_icon),&#10;                                contentDescription = &quot;Undo&quot;,&#10;                                tint = colors.onBackground,&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Icon(&#10;                                modifier = Modifier&#10;                                    .padding(6.dp)&#10;                                    .clickable(onClick = {&#10;                                        graphicOverlay?.redo()&#10;                                    }),&#10;                                painter = painterResource(id = R.drawable.redo_icon),&#10;                                contentDescription = &quot;Redo&quot;,&#10;                                tint = colors.onBackground,&#10;                            )&#10;                        }&#10;&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .padding(horizontal = 16.dp)&#10;                        ) {&#10;                            Row {&#10;&#10;                                Text(&#10;                                    text = stringResource(R.string.size),&#10;                                    style = MaterialTheme.typography.labelSmall,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    color = colors.onSurfaceVariant,&#10;                                    modifier = Modifier&#10;                                        .align(Alignment.CenterVertically)&#10;                                )&#10;&#10;                                Spacer(modifier = Modifier.width(16.dp))&#10;&#10;                                Slider(&#10;                                    value = brushSize,&#10;                                    colors = SliderDefaults.colors(&#10;                                        thumbColor = colors.primary, // White color for thumb&#10;                                        activeTrackColor = colors.primary, // Primary fill color for active track&#10;                                        inactiveTrackColor = colors.custom300 // Gray color for inactive track (adjust if custom100 is not gray)&#10;                                    ),&#10;&#10;&#10;                                    onValueChange = {&#10;                                        brushSize = it&#10;                                        graphicOverlay?.setBrushSize(it)&#10;                                    },&#10;                                    valueRange = 10f..100f,&#10;                                )&#10;                            }&#10;&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .padding(horizontal = 16.dp)&#10;                        ) {&#10;                            Row {&#10;&#10;                                Text(&#10;                                    text = stringResource(R.string.offset),&#10;                                    style = MaterialTheme.typography.labelSmall,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    color = colors.onSurfaceVariant,&#10;                                    modifier = Modifier&#10;                                        .align(Alignment.CenterVertically)&#10;                                )&#10;&#10;                                Spacer(modifier = Modifier.width(16.dp))&#10;&#10;                                Slider(&#10;                                    value = brushOffset,&#10;                                    colors = SliderDefaults.colors(&#10;                                        thumbColor = colors.primary, // White color for thumb&#10;                                        activeTrackColor = colors.primary, // Primary fill color for active track&#10;                                        inactiveTrackColor = colors.custom300 // Gray color for inactive track (adjust if custom100 is not gray)&#10;                                    ),&#10;                                    onValueChange = {&#10;                                        brushOffset = it&#10;                                        graphicOverlay?.setBrushOffset(it)&#10;                                    },&#10;                                    valueRange = 0f..150f&#10;&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        //tabs&#10;                        val tabItems = listOf(&#10;                            R.drawable.ai_tab_item_icon,&#10;                            R.drawable.eraser_icon,&#10;                            R.drawable.ic_transform,&#10;                            R.drawable.brush_tab_item_icon,&#10;                            R.drawable.tick_icon_thick&#10;                        )&#10;&#10;                        LaunchedEffect(selected) {&#10;                            when (selected) {&#10;                                0 -&gt; {&#10;                                    if (currentMode != DrawViewAction.NONE) {&#10;                                        graphicOverlay?.hideBrush()&#10;                                        currentMode = DrawViewAction.NONE&#10;                                    }&#10;&#10;                                    graphicOverlay?.getCurrentBitmap()?.let { bitmap -&gt;&#10;                                        val transparentBitmap = Bitmap.createBitmap(&#10;                                            bitmap.width,&#10;                                            bitmap.height,&#10;                                            Bitmap.Config.ARGB_8888&#10;                                        ).apply { eraseColor(AndroidColor.TRANSPARENT) }&#10;                                        Canvas(transparentBitmap).drawBitmap(bitmap, 0f, 0f, null)&#10;                                        removeBackgroundBitmap = transparentBitmap.asImageBitmap()&#10;                                    }&#10;&#10;                                    setSelected(1) // Reset to eraser mode&#10;                                }&#10;&#10;                                1 -&gt; {&#10;                                    if (currentMode != DrawViewAction.ERASE_BACKGROUND) {&#10;                                        currentMode = DrawViewAction.ERASE_BACKGROUND&#10;                                        graphicOverlay?.setAction(DrawViewAction.ERASE_BACKGROUND)&#10;                                    }&#10;                                }&#10;&#10;                                2 -&gt; { // Transform mode&#10;                                    // switch overlay into transform mode&#10;                                    graphicOverlay?.setAction(DrawViewAction.TRANSFORM)&#10;                                    currentMode = DrawViewAction.TRANSFORM&#10;&#10;                                }&#10;&#10;                                3 -&gt; {&#10;                                    if (currentMode != DrawViewAction.RECOVER_AREA) {&#10;                                        currentMode = DrawViewAction.RECOVER_AREA&#10;                                    }&#10;                                }&#10;&#10;                                4 -&gt; {&#10;                                    graphicOverlay?.hideBrush()&#10;                                    currentMode = DrawViewAction.NONE&#10;&#10;                                    graphicOverlay?.getCurrentBitmap()?.let { bitmap -&gt;&#10;                                        val transparentBitmap = Bitmap.createBitmap(&#10;                                            bitmap.width,&#10;                                            bitmap.height,&#10;                                            Bitmap.Config.ARGB_8888&#10;                                        ).apply { eraseColor(AndroidColor.TRANSPARENT) }&#10;                                        Canvas(transparentBitmap).drawBitmap(bitmap, 0f, 0f, null)&#10;                                        finalBitmap = transparentBitmap.asImageBitmap()&#10;                                    }&#10;                                    setSelected(1) // Reset to eraser mode&#10;                                }&#10;&#10;                            }&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                        CustomTab(&#10;                            selectedItemIndex = selected,&#10;                            items = tabItems,&#10;                            modifier = Modifier,&#10;                            tabWidth = 80.dp,&#10;                            onClick = setSelected&#10;                        )&#10;&#10;&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;&#10;&#10;                        var adViewLoadState by remember { mutableStateOf(true) }&#10;                        var callback by remember { mutableStateOf(false) }&#10;&#10;                        if (!isPremium) {&#10;&#10;                            AnimatedVisibility(adViewLoadState) {&#10;                            Surface(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .animateContentSize()&#10;                                    .heightIn(min = 54.dp) // match banner height&#10;                            ) {&#10;                                Box(contentAlignment = Alignment.Center) {&#10;                                    if (!callback) {&#10;                                        Text(&#10;                                            text = stringResource(R.string.advertisement),&#10;                                            style = MaterialTheme.typography.bodyMedium,&#10;                                            fontWeight = FontWeight.Medium,&#10;                                            color = colors.onSurfaceVariant,&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .wrapContentSize(align = Alignment.Center)&#10;                                        )&#10;                                    }&#10;&#10;                                    AdaptiveBannerAd(&#10;                                        adUnit = AdIdsFactory.getBannerAdId(),&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .animateContentSize()&#10;                                            .align(Alignment.Center),&#10;                                        onAdLoaded = { isLoaded -&gt;&#10;                                            callback = true&#10;                                            adViewLoadState = isLoaded&#10;                                            Logger.d(TAG, &quot;AdaptiveBannerAd: onAdLoaded: $isLoaded&quot;)&#10;                                        }&#10;                                    )&#10;&#10;                                    /*AdMobBanner(&#10;                                        adUnit = AdIdsFactory.getBannerAdId(),&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .animateContentSize()&#10;                                            .align(Alignment.Center),&#10;                                        adSize = AdSize.BANNER, // or adaptive size if needed&#10;                                        onAdLoaded = { isLoaded -&gt;&#10;                                            adLoadState = isLoaded&#10;                                            Logger.d(TAG, &quot;AdMobBanner: onAdLoaded: $isLoaded&quot;)&#10;                                        }&#10;                                    )*/&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        }&#10;&#10;                    }&#10;&#10;                }&#10;&#10;                finalBitmap?.let { bitmap -&gt;&#10;                    Dialog(onDismissRequest = { }) {&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .background(&#10;                                    color = colors.background,&#10;                                    shape = RoundedCornerShape(16.dp)&#10;                                )&#10;                                .padding(16.dp),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&#10;                                &quot;${stringResource(R.string.preview_of_final_image)} \uD83D\uDC47&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                color = colors.onBackground,&#10;                                modifier = Modifier&#10;                                    .align(Alignment.CenterHorizontally),&#10;                            )&#10;                            Spacer(Modifier.size(16.dp))&#10;                            Image(&#10;                                bitmap = bitmap,&#10;                                contentDescription = &quot;Preview of ticket&quot;&#10;                            )&#10;                            Spacer(Modifier.size(4.dp))&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Button(&#10;                                    onClick = { finalBitmap = null },&#10;                                    modifier = Modifier&#10;                                        .weight(1f) // Takes 50% of the width&#10;                                        .padding(end = 3.dp) // Optional: small padding to separate buttons&#10;                                ) {&#10;                                    Text(stringResource(R.string.close), modifier = Modifier.padding(horizontal = 10.dp))&#10;                                }&#10;&#10;                                Spacer(Modifier.size(6.dp))&#10;&#10;                                Button(&#10;                                    onClick = {&#10;                                        onSaveImage(bitmap)&#10;                                        finalBitmap = null&#10;                                    },&#10;                                    modifier = Modifier&#10;                                        .weight(1f) // Takes 50% of the width&#10;                                        .padding(start = 3.dp) // Optional: small padding to separate buttons&#10;                                ) {&#10;                                    Text(stringResource(R.string.save), modifier = Modifier.padding(horizontal = 10.dp))&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                removeBackgroundBitmap?.let { bitmap -&gt;&#10;                    Dialog(onDismissRequest = { }) {&#10;&#10;                        var removeBg by remember { mutableStateOf(false) }&#10;                        val boxModifier = if (removeBg) {&#10;                            Modifier&#10;                                .background(&#10;                                    color = colors.background,&#10;                                    shape = RoundedCornerShape(16.dp)&#10;                                )&#10;                                .animatedBorder(&#10;                                    borderColors = listOf(Color.Red, Color.Green, Color.Blue),&#10;                                    backgroundColor = colors.background,&#10;                                    shape = RoundedCornerShape(16.dp),&#10;                                    borderWidth = 3.dp,&#10;                                    animationDurationInMillis = 2500&#10;                                )&#10;                                .animateContentSize()&#10;                        } else {&#10;                            Modifier&#10;                                .background(&#10;                                    color = colors.background,&#10;                                    shape = RoundedCornerShape(16.dp)&#10;                                )&#10;                                .animateContentSize()&#10;                        }&#10;                        Box(&#10;                            modifier = boxModifier,&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;&#10;&#10;                            if (removeBg) {&#10;                                LottieAnimation(&#10;                                    composition = composition,&#10;                                    modifier = Modifier&#10;                                        .width(160.dp)&#10;                                        .aspectRatio(1f)&#10;                                        .align(Alignment.Center),&#10;                                    iterations = LottieConstants.IterateForever,&#10;                                )&#10;                                LaunchedEffect(processingStage) {&#10;                                    if (processingStage == ProcessingStage.COMPLETED ||&#10;                                        processingStage == ProcessingStage.ERROR ||&#10;                                        processingStage == ProcessingStage.NO_NETWORK_AVAILABLE&#10;                                    ) {&#10;&#10;                                        removeBackgroundBitmap = null&#10;                                    }&#10;                                }&#10;&#10;                            } else {&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .padding(16.dp)&#10;                                        .background(&#10;                                            color = colors.background,&#10;                                            shape = RoundedCornerShape(16.dp)&#10;                                        )&#10;                                        .align(Alignment.Center),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally&#10;                                ) {&#10;                                    Text(&#10;                                        &quot;${stringResource(R.string.do_you_want_to_remove_background)} \uD83D\uDC47&quot;,&#10;                                        style = MaterialTheme.typography.titleMedium,&#10;                                        textAlign = TextAlign.Center,&#10;                                        color = colors.onBackground,&#10;                                        modifier = Modifier&#10;                                            .align(Alignment.CenterHorizontally),&#10;                                    )&#10;                                    Spacer(Modifier.size(16.dp))&#10;                                    Image(&#10;                                        bitmap = bitmap,&#10;                                        contentDescription = &quot;Preview of Removed Background image&quot;&#10;                                    )&#10;                                    Spacer(Modifier.size(4.dp))&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Button(&#10;                                            onClick = { removeBackgroundBitmap = null },&#10;                                            modifier = Modifier&#10;                                                .weight(1f) // Takes 50% of the width&#10;                                                .padding(end = 3.dp)&#10;                                        ) {&#10;                                            Text(&#10;                                                stringResource(R.string.no),&#10;                                                modifier = Modifier.padding(horizontal = 10.dp)&#10;                                            )&#10;                                        }&#10;&#10;                                        Spacer(Modifier.size(6.dp))&#10;&#10;                                        Button(&#10;                                            onClick = {&#10;                                                removeBg = true&#10;                                                onRemoveBackgroundAi(bitmap)&#10;&#10;                                            },&#10;                                            modifier = Modifier&#10;                                                .weight(1f) // Takes 50% of the width&#10;                                                .padding(end = 3.dp)&#10;                                        ) {&#10;                                            Text(&#10;                                                stringResource(R.string.yes),&#10;                                                modifier = Modifier.padding(horizontal = 10.dp)&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                        }&#10;&#10;                    }&#10;                }&#10;&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showSystemUi = true, device = &quot;id:pixel_5&quot;)&#10;@Composable&#10;fun ImageProcessingScreenPreview() {&#10;&#10;    PreviewContainer {&#10;        CutOutImageScreen(&#10;            uiState = CutOutImageScreenUiState(&#10;                showLoading = false,&#10;                errorMessage = null,&#10;            ),&#10;            isPremium = false,&#10;            onBackClick = {},&#10;            onGetProClick = {}&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ots.aipassportphotomaker.presentation.ui.cutout&#10;&#10;import android.annotation.SuppressLint&#10;import android.graphics.Bitmap&#10;import android.graphics.Canvas&#10;import android.graphics.drawable.BitmapDrawable&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectTapGestures&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.asPaddingValues&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.heightIn&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.systemBars&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.layout.wrapContentSize&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Slider&#10;import androidx.compose.material3.SliderDefaults&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableFloatStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.produceState&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.ImageBitmap&#10;import androidx.compose.ui.graphics.asAndroidBitmap&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.core.graphics.createBitmap&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import coil.ImageLoader&#10;import coil.request.ImageRequest&#10;import com.airbnb.lottie.compose.LottieAnimation&#10;import com.airbnb.lottie.compose.LottieCompositionSpec&#10;import com.airbnb.lottie.compose.LottieConstants&#10;import com.airbnb.lottie.compose.rememberLottieComposition&#10;import com.google.android.gms.ads.AdSize&#10;import com.ots.aipassportphotomaker.R&#10;import com.ots.aipassportphotomaker.adsmanager.admob.AdMobBanner&#10;import com.ots.aipassportphotomaker.adsmanager.admob.AdaptiveBannerAd&#10;import com.ots.aipassportphotomaker.adsmanager.admob.adids.AdIdsFactory&#10;import com.ots.aipassportphotomaker.common.ext.animatedBorder&#10;import com.ots.aipassportphotomaker.common.ext.collectAsEffect&#10;import com.ots.aipassportphotomaker.common.preview.PreviewContainer&#10;import com.ots.aipassportphotomaker.common.utils.AnalyticsConstants&#10;import com.ots.aipassportphotomaker.common.utils.DrawViewAction&#10;import com.ots.aipassportphotomaker.common.utils.FileUtils.saveBitmapToInternalStorage&#10;import com.ots.aipassportphotomaker.common.utils.GraphicOverlay&#10;import com.ots.aipassportphotomaker.common.utils.ImageUtils.saveBitmapToGallery&#10;import com.ots.aipassportphotomaker.common.utils.Logger&#10;import com.ots.aipassportphotomaker.domain.model.ProcessingStage&#10;import com.ots.aipassportphotomaker.presentation.ui.bottom_nav.NavigationBarSharedViewModel&#10;import com.ots.aipassportphotomaker.presentation.ui.components.CommonTopBar&#10;import com.ots.aipassportphotomaker.presentation.ui.components.CustomTab&#10;import com.ots.aipassportphotomaker.presentation.ui.components.LoaderFullScreen&#10;import com.ots.aipassportphotomaker.presentation.ui.main.MainRouter&#10;import com.ots.aipassportphotomaker.presentation.ui.theme.colors&#10;import com.ots.aipassportphotomaker.presentation.ui.theme.custom300&#10;import com.ots.aipassportphotomaker.presentation.viewmodel.SharedViewModel&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.io.File&#10;import android.graphics.Color as AndroidColor&#10;&#10;// Created by amanullah on 04/09/2025.&#10;// Copyright (c) 2025 Ozi Publishing. All rights reserved.&#10;&#10;@Composable&#10;fun CutOutImagePage(&#10;    mainRouter: MainRouter,&#10;    viewModel: CutOutImageScreenViewModel = hiltViewModel(),&#10;    sharedViewModel: NavigationBarSharedViewModel&#10;) {&#10;    val TAG = &quot;CutOutImagePage&quot;&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val context = LocalContext.current&#10;    val activity = context as ComponentActivity&#10;    val uiScope = rememberCoroutineScope()&#10;&#10;    val imageUrl = viewModel.imageUrl&#10;    val selectedColor = viewModel.selectedColor&#10;&#10;    viewModel.navigationState.collectAsEffect { navigationState -&gt;&#10;&#10;        Log.d(TAG, &quot;CutOutImagePage: Navigation State: $navigationState, ImageUrl: $imageUrl&quot;)&#10;        when (navigationState) {&#10;            is CutOutImageScreenNavigationState.SavedImageScreen -&gt; mainRouter.navigateFromCutoutToSavedImageScreen(&#10;                documentId = navigationState.documentId,&#10;                imagePath = uiState.imageUrl,&#10;                sourceScreen = &quot;CutOutImageScreen&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    val processingStage by viewModel.processingStage.collectAsState()&#10;&#10;    val commonSharedViewModel: SharedViewModel = hiltViewModel(activity)&#10;&#10;    CutOutImageScreen(&#10;        uiState = uiState,&#10;        processingStage = processingStage,&#10;        selectedColor = selectedColor,&#10;        isPremium = viewModel.isPremiumUser(),&#10;        onBackClick = {&#10;            viewModel.sendEvent(AnalyticsConstants.CLICKED, &quot;btnBack_CutOutImageScreen&quot;)&#10;            mainRouter.goBack()&#10;&#10;            viewModel.showInterstitialAd(activity) { }&#10;        },&#10;        onGetProClick = {&#10;            viewModel.sendEvent(AnalyticsConstants.CLICKED, &quot;btnGetPro_CutOutImageScreen&quot;)&#10;            mainRouter.navigateToPremiumScreen()&#10;        },&#10;        onSaveImage = { bitmap -&gt;&#10;            viewModel.sendEvent(AnalyticsConstants.CLICKED, &quot;btnSave_CutOutImageScreen&quot;)&#10;            uiScope.launch {&#10;                when (viewModel.sourceScreen) {&#10;                    &quot;EditImageScreen&quot; -&gt; {&#10;                        Logger.i(TAG, &quot;onSaveImage: Navigating back to EditImageScreen&quot;)&#10;                        val internalPath =&#10;                            saveBitmapToInternalStorage(context, bitmap.asAndroidBitmap())&#10;                        if (internalPath != null) {&#10;                            Logger.i(TAG, &quot;Image saved successfully: $internalPath&quot;)&#10;                            commonSharedViewModel.setEditedImageResult(internalPath)&#10;&#10;                            delay(100)&#10;                            mainRouter.goBack()&#10;&#10;                            viewModel.showInterstitialAd(activity) { }&#10;&#10;                        } else {&#10;                            Logger.e(TAG, &quot;Failed to save image&quot;)&#10;                        }&#10;                    }&#10;&#10;                    &quot;HomeScreen&quot; -&gt; {&#10;                        Logger.i(TAG, &quot;onSaveImage: Navigating to final screen&quot;)&#10;                        val savedUri = saveBitmapToGallery(context, bitmap.asAndroidBitmap())&#10;                        if (savedUri != null) {&#10;&#10;                            viewModel.onImageSaved(savedUri.toString())&#10;                            viewModel.showInterstitialAd(activity) { }&#10;&#10;                            /*viewModel.loadAndShowRewardedAd(&#10;                                activity,&#10;                                onAdClosed = {&#10;                                    viewModel.onImageSaved(savedUri.toString())&#10;                                },&#10;                                onRewardedEarned = { isEarned -&gt;&#10;                                    if (!isEarned) {&#10;                                        viewModel.onImageSaved(savedUri.toString())&#10;                                        viewModel.showInterstitialAd(activity) { }&#10;                                    }&#10;&#10;                                })*/&#10;&#10;                            Logger.i(TAG, &quot;Image saved successfully: $savedUri&quot;)&#10;&#10;                        } else {&#10;                            Logger.e(TAG, &quot;Failed to save image&quot;)&#10;                        }&#10;                    }&#10;&#10;                    else -&gt; {&#10;                        Logger.i(&#10;                            TAG,&#10;                            &quot;onSaveImage: Unknown sourceScreen, defaulting to EditImageScreen: ${uiState.sourceScreen}&quot;&#10;                        )&#10;                        val savedUri = saveBitmapToGallery(context, bitmap.asAndroidBitmap())&#10;                        if (savedUri != null) {&#10;                            Logger.i(TAG, &quot;Image saved successfully: $savedUri&quot;)&#10;                            commonSharedViewModel.setEditedImageResult(savedUri.toString())&#10;&#10;                            delay(100)&#10;                            mainRouter.goBack()&#10;&#10;                        } else {&#10;                            Logger.e(TAG, &quot;Failed to save image&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        onRemoveBackgroundAi = { bitmap -&gt;&#10;            uiScope.launch {&#10;                val internalPath = saveBitmapToInternalStorage(context, bitmap.asAndroidBitmap())&#10;                if (internalPath != null) {&#10;                    Logger.i(TAG, &quot;Image saved successfully: $internalPath&quot;)&#10;                    viewModel.removeBackground(File(internalPath))&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    BackHandler {&#10;        viewModel.sendEvent(AnalyticsConstants.CLICKED, &quot;backPress_CutOutImageScreen&quot;)&#10;        mainRouter.goBack()&#10;        viewModel.showInterstitialAd(activity) { }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@SuppressLint(&quot;UseKtx&quot;)&#10;@Composable&#10;private fun CutOutImageScreen(&#10;    uiState: CutOutImageScreenUiState,&#10;    processingStage: ProcessingStage = ProcessingStage.NONE,&#10;    selectedColor: String? = null,&#10;    isPremium: Boolean,&#10;    onSaveImage: (ImageBitmap) -&gt; Unit = {},&#10;    onRemoveBackgroundAi: (ImageBitmap) -&gt; Unit = {},&#10;    onBackClick: () -&gt; Unit = {},&#10;    onGetProClick: () -&gt; Unit = {},&#10;) {&#10;    val composition by rememberLottieComposition(LottieCompositionSpec.RawRes(R.raw.ai_erase))&#10;    val systemBarsPadding = WindowInsets.systemBars.asPaddingValues()&#10;&#10;    val TAG = &quot;CutOutImageScreen&quot;&#10;    Surface(&#10;        modifier = Modifier&#10;            .padding(bottom = systemBarsPadding.calculateBottomPadding())&#10;    ) {&#10;&#10;        val context = LocalContext.current&#10;        val isLoading = uiState.showLoading&#10;        val errorMessage = uiState.errorMessage&#10;        val backgroundColor = uiState.selectedColor&#10;        val imageUrl = uiState.imageUrl&#10;&#10;        val uiScope = rememberCoroutineScope()&#10;&#10;        var graphicOverlay by remember { mutableStateOf&lt;GraphicOverlay?&gt;(null) }&#10;        var currentMode by remember { mutableStateOf(DrawViewAction.ERASE_BACKGROUND) }&#10;        var brushSize by remember { mutableFloatStateOf(50f) }&#10;        var brushOffset by remember { mutableFloatStateOf(0f) }&#10;        var finalBitmap: ImageBitmap? by remember { mutableStateOf(null) }&#10;        var removeBackgroundBitmap: ImageBitmap? by remember { mutableStateOf(null) }&#10;        val (selected, setSelected) = remember { mutableStateOf(1) }&#10;&#10;        Logger.i(&#10;            &quot;CutOutImagePage&quot;,&#10;            &quot;Rendering with imageUrl: $imageUrl, isLoading: $isLoading, errorMessage: $errorMessage&quot;&#10;        )&#10;&#10;        if (errorMessage != null) Toast.makeText(context, errorMessage, Toast.LENGTH_SHORT).show()&#10;&#10;        Column(&#10;            modifier = Modifier&#10;                .background(colors.background)&#10;                .fillMaxWidth()&#10;                .pointerInput(Unit) {&#10;                    detectTapGestures(&#10;                        onTap = {&#10;&#10;                        })&#10;                }&#10;        ) {&#10;            CommonTopBar(&#10;                title = stringResource(id = R.string.cut_out),&#10;                showGetProButton = !isPremium,&#10;                onBackClick = {&#10;                    onBackClick.invoke()&#10;&#10;                },&#10;                onGetProClick = {&#10;                    onGetProClick.invoke()&#10;&#10;                }&#10;            )&#10;&#10;            if (isLoading) {&#10;                LoaderFullScreen()&#10;            } else {&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                ) {&#10;&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .background(colors.background)&#10;                            .fillMaxSize()&#10;                            .pointerInput(Unit) {&#10;                                detectTapGestures(&#10;                                    onTap = {&#10;&#10;                                    })&#10;                            }&#10;                    ) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .aspectRatio(1f)&#10;                                .background(Color.LightGray)&#10;                        ) {&#10;&#10;                            Image(&#10;                                painter = painterResource(id = R.drawable.transparent_bg),&#10;                                contentDescription = &quot;Transparent Background&quot;,&#10;                                modifier = Modifier&#10;                                    .matchParentSize(),&#10;                                contentScale = ContentScale.Crop&#10;                            )&#10;&#10;                            // Load the image as a bitmap&#10;                            val imageLoader = ImageLoader.Builder(context).build()&#10;                            var bitmap by remember { mutableStateOf&lt;Bitmap?&gt;(null) }&#10;&#10;                            LaunchedEffect(imageUrl) {&#10;                                if (!imageUrl.isNullOrEmpty()) {&#10;                                    try {&#10;                                        val imageLoader = ImageLoader.Builder(context).build()&#10;                                        val request = ImageRequest.Builder(context)&#10;                                            .data(imageUrl)&#10;                                            .target { drawable -&gt;&#10;                                                val newBitmap = when (drawable) {&#10;                                                    is BitmapDrawable -&gt; drawable.bitmap&#10;                                                    else -&gt; {&#10;                                                        val bmp = createBitmap(&#10;                                                            drawable.intrinsicWidth,&#10;                                                            drawable.intrinsicHeight,&#10;                                                            Bitmap.Config.ARGB_8888&#10;                                                        )&#10;                                                        val canvas = Canvas(bmp)&#10;                                                        drawable.setBounds(&#10;                                                            0,&#10;                                                            0,&#10;                                                            canvas.width,&#10;                                                            canvas.height&#10;                                                        )&#10;                                                        drawable.draw(canvas)&#10;                                                        bmp&#10;                                                    }&#10;                                                }&#10;&#10;                                                // Update both bitmap state and GraphicOverlay&#10;                                                bitmap = newBitmap&#10;                                                graphicOverlay?.setBitmap(newBitmap)&#10;&#10;                                                Logger.i(&#10;                                                    &quot;CutOutImageScreen&quot;,&#10;                                                    &quot;Image updated successfully: ${imageUrl}&quot;&#10;                                                )&#10;                                            }&#10;                                            .build()&#10;                                        imageLoader.enqueue(request)&#10;                                    } catch (e: Exception) {&#10;                                        Logger.e(&#10;                                            &quot;CutOutImageScreen&quot;,&#10;                                            &quot;Failed to load image: ${e.message}&quot;,&#10;                                            e&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            AndroidView(&#10;                                factory = { ctx -&gt;&#10;&#10;                                    GraphicOverlay(context, null).apply {&#10;                                        graphicOverlay = this&#10;                                    }&#10;                                },&#10;                                update = { view -&gt;&#10;                                    if (view.getCurrentBitmap() == null &amp;&amp; bitmap != null) {&#10;                                        view.setBitmap(bitmap)&#10;                                    }&#10;&#10;                                    // Only update brush size if it actually changed&#10;                                    if (view.getBrushSize() != brushSize) {&#10;                                        view.setBrushSize(brushSize)&#10;                                    }&#10;&#10;                                    // Update brush offset&#10;                                    if (view.getBrushOffset() != brushOffset) {&#10;                                        view.setBrushOffset(brushOffset)&#10;                                    }&#10;&#10;                                    // Only update action if it actually changed&#10;                                    if (view.getCurrentAction() != currentMode) {&#10;                                        view.setAction(currentMode)&#10;                                    }&#10;                                },&#10;                                modifier = Modifier&#10;                                    .padding(horizontal = 8.dp)&#10;                                    .matchParentSize()&#10;                            )&#10;                        }&#10;&#10;&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                    }&#10;&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .align(Alignment.BottomCenter)&#10;                    ) {&#10;&#10;&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .padding(end = 16.dp)&#10;                                .align(Alignment.End)&#10;                        ) {&#10;                            Icon(&#10;                                modifier = Modifier&#10;                                    .padding(6.dp)&#10;                                    .clickable(onClick = {&#10;                                        graphicOverlay?.undo()&#10;                                    }),&#10;                                painter = painterResource(id = R.drawable.undo_icon),&#10;                                contentDescription = &quot;Undo&quot;,&#10;                                tint = colors.onBackground,&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Icon(&#10;                                modifier = Modifier&#10;                                    .padding(6.dp)&#10;                                    .clickable(onClick = {&#10;                                        graphicOverlay?.redo()&#10;                                    }),&#10;                                painter = painterResource(id = R.drawable.redo_icon),&#10;                                contentDescription = &quot;Redo&quot;,&#10;                                tint = colors.onBackground,&#10;                            )&#10;                        }&#10;&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .padding(horizontal = 16.dp)&#10;                        ) {&#10;                            Row {&#10;&#10;                                Text(&#10;                                    text = stringResource(R.string.size),&#10;                                    style = MaterialTheme.typography.labelSmall,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    color = colors.onSurfaceVariant,&#10;                                    modifier = Modifier&#10;                                        .align(Alignment.CenterVertically)&#10;                                )&#10;&#10;                                Spacer(modifier = Modifier.width(16.dp))&#10;&#10;                                Slider(&#10;                                    value = brushSize,&#10;                                    colors = SliderDefaults.colors(&#10;                                        thumbColor = colors.primary, // White color for thumb&#10;                                        activeTrackColor = colors.primary, // Primary fill color for active track&#10;                                        inactiveTrackColor = colors.custom300 // Gray color for inactive track (adjust if custom100 is not gray)&#10;                                    ),&#10;&#10;&#10;                                    onValueChange = {&#10;                                        brushSize = it&#10;                                        graphicOverlay?.setBrushSize(it)&#10;                                    },&#10;                                    valueRange = 10f..100f,&#10;                                )&#10;                            }&#10;&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .padding(horizontal = 16.dp)&#10;                        ) {&#10;                            Row {&#10;&#10;                                Text(&#10;                                    text = stringResource(R.string.offset),&#10;                                    style = MaterialTheme.typography.labelSmall,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    color = colors.onSurfaceVariant,&#10;                                    modifier = Modifier&#10;                                        .align(Alignment.CenterVertically)&#10;                                )&#10;&#10;                                Spacer(modifier = Modifier.width(16.dp))&#10;&#10;                                Slider(&#10;                                    value = brushOffset,&#10;                                    colors = SliderDefaults.colors(&#10;                                        thumbColor = colors.primary, // White color for thumb&#10;                                        activeTrackColor = colors.primary, // Primary fill color for active track&#10;                                        inactiveTrackColor = colors.custom300 // Gray color for inactive track (adjust if custom100 is not gray)&#10;                                    ),&#10;                                    onValueChange = {&#10;                                        brushOffset = it&#10;                                        graphicOverlay?.setBrushOffset(it)&#10;                                    },&#10;                                    valueRange = 0f..150f&#10;&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        //tabs&#10;                        val tabItems = listOf(&#10;                            R.drawable.ai_tab_item_icon,&#10;                            R.drawable.eraser_icon,&#10;                            R.drawable.ic_transform,&#10;                            R.drawable.brush_tab_item_icon,&#10;                            R.drawable.tick_icon_thick&#10;                        )&#10;&#10;                        LaunchedEffect(selected) {&#10;                            when (selected) {&#10;                                0 -&gt; {&#10;                                    if (currentMode != DrawViewAction.NONE) {&#10;                                        graphicOverlay?.hideBrush()&#10;                                        currentMode = DrawViewAction.NONE&#10;                                    }&#10;&#10;                                    graphicOverlay?.getCurrentBitmap()?.let { bitmap -&gt;&#10;                                        val transparentBitmap = Bitmap.createBitmap(&#10;                                            bitmap.width,&#10;                                            bitmap.height,&#10;                                            Bitmap.Config.ARGB_8888&#10;                                        ).apply { eraseColor(AndroidColor.TRANSPARENT) }&#10;                                        Canvas(transparentBitmap).drawBitmap(bitmap, 0f, 0f, null)&#10;                                        removeBackgroundBitmap = transparentBitmap.asImageBitmap()&#10;                                    }&#10;&#10;                                    setSelected(1) // Reset to eraser mode&#10;                                }&#10;&#10;                                1 -&gt; {&#10;                                    if (currentMode != DrawViewAction.ERASE_BACKGROUND) {&#10;                                        currentMode = DrawViewAction.ERASE_BACKGROUND&#10;                                        graphicOverlay?.setAction(DrawViewAction.ERASE_BACKGROUND)&#10;                                    }&#10;                                }&#10;&#10;                                2 -&gt; { // Transform mode&#10;                                    // switch overlay into transform mode&#10;                                    graphicOverlay?.setAction(DrawViewAction.TRANSFORM)&#10;                                    currentMode = DrawViewAction.TRANSFORM&#10;&#10;                                }&#10;&#10;                                3 -&gt; {&#10;                                    if (currentMode != DrawViewAction.RECOVER_AREA) {&#10;                                        currentMode = DrawViewAction.RECOVER_AREA&#10;                                    }&#10;                                }&#10;&#10;                                4 -&gt; {&#10;                                    graphicOverlay?.hideBrush()&#10;                                    currentMode = DrawViewAction.NONE&#10;&#10;                                    graphicOverlay?.getCurrentBitmap()?.let { bitmap -&gt;&#10;                                        val transparentBitmap = Bitmap.createBitmap(&#10;                                            bitmap.width,&#10;                                            bitmap.height,&#10;                                            Bitmap.Config.ARGB_8888&#10;                                        ).apply { eraseColor(AndroidColor.TRANSPARENT) }&#10;                                        Canvas(transparentBitmap).drawBitmap(bitmap, 0f, 0f, null)&#10;                                        finalBitmap = transparentBitmap.asImageBitmap()&#10;                                    }&#10;                                    setSelected(1) // Reset to eraser mode&#10;                                }&#10;&#10;                            }&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                        CustomTab(&#10;                            selectedItemIndex = selected,&#10;                            items = tabItems,&#10;                            modifier = Modifier,&#10;                            tabWidth = 80.dp,&#10;                            onClick = setSelected&#10;                        )&#10;&#10;&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;&#10;&#10;                        var adViewLoadState by remember { mutableStateOf(true) }&#10;                        var callback by remember { mutableStateOf(false) }&#10;&#10;                        if (!isPremium) {&#10;&#10;                            AnimatedVisibility(adViewLoadState) {&#10;                            Surface(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .animateContentSize()&#10;                                    .heightIn(min = 54.dp) // match banner height&#10;                            ) {&#10;                                Box(contentAlignment = Alignment.Center) {&#10;                                    if (!callback) {&#10;                                        Text(&#10;                                            text = stringResource(R.string.advertisement),&#10;                                            style = MaterialTheme.typography.bodyMedium,&#10;                                            fontWeight = FontWeight.Medium,&#10;                                            color = colors.onSurfaceVariant,&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .wrapContentSize(align = Alignment.Center)&#10;                                        )&#10;                                    }&#10;&#10;                                    AdaptiveBannerAd(&#10;                                        adUnit = AdIdsFactory.getBannerAdId(),&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .animateContentSize()&#10;                                            .align(Alignment.Center),&#10;                                        onAdLoaded = { isLoaded -&gt;&#10;                                            callback = true&#10;                                            adViewLoadState = isLoaded&#10;                                            Logger.d(TAG, &quot;AdaptiveBannerAd: onAdLoaded: $isLoaded&quot;)&#10;                                        }&#10;                                    )&#10;&#10;                                    /*AdMobBanner(&#10;                                        adUnit = AdIdsFactory.getBannerAdId(),&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .animateContentSize()&#10;                                            .align(Alignment.Center),&#10;                                        adSize = AdSize.BANNER, // or adaptive size if needed&#10;                                        onAdLoaded = { isLoaded -&gt;&#10;                                            adLoadState = isLoaded&#10;                                            Logger.d(TAG, &quot;AdMobBanner: onAdLoaded: $isLoaded&quot;)&#10;                                        }&#10;                                    )*/&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        }&#10;&#10;                    }&#10;&#10;                }&#10;&#10;                finalBitmap?.let { bitmap -&gt;&#10;                    Dialog(onDismissRequest = { }) {&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .background(&#10;                                    color = colors.background,&#10;                                    shape = RoundedCornerShape(16.dp)&#10;                                )&#10;                                .padding(16.dp),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&#10;                                &quot;${stringResource(R.string.preview_of_final_image)} \uD83D\uDC47&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                color = colors.onBackground,&#10;                                modifier = Modifier&#10;                                    .align(Alignment.CenterHorizontally),&#10;                            )&#10;                            Spacer(Modifier.size(16.dp))&#10;                            Image(&#10;                                bitmap = bitmap,&#10;                                contentDescription = &quot;Preview of ticket&quot;&#10;                            )&#10;                            Spacer(Modifier.size(4.dp))&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Button(&#10;                                    onClick = { finalBitmap = null },&#10;                                    modifier = Modifier&#10;                                        .weight(1f) // Takes 50% of the width&#10;                                        .padding(end = 3.dp) // Optional: small padding to separate buttons&#10;                                ) {&#10;                                    Text(stringResource(R.string.close), modifier = Modifier.padding(horizontal = 10.dp))&#10;                                }&#10;&#10;                                Spacer(Modifier.size(6.dp))&#10;&#10;                                Button(&#10;                                    onClick = {&#10;                                        onSaveImage(bitmap)&#10;                                        finalBitmap = null&#10;                                    },&#10;                                    modifier = Modifier&#10;                                        .weight(1f) // Takes 50% of the width&#10;                                        .padding(start = 3.dp) // Optional: small padding to separate buttons&#10;                                ) {&#10;                                    Text(stringResource(R.string.save), modifier = Modifier.padding(horizontal = 10.dp))&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                removeBackgroundBitmap?.let { bitmap -&gt;&#10;                    Dialog(onDismissRequest = { }) {&#10;&#10;                        var removeBg by remember { mutableStateOf(false) }&#10;                        val boxModifier = if (removeBg) {&#10;                            Modifier&#10;                                .background(&#10;                                    color = colors.background,&#10;                                    shape = RoundedCornerShape(16.dp)&#10;                                )&#10;                                .animatedBorder(&#10;                                    borderColors = listOf(Color.Red, Color.Green, Color.Blue),&#10;                                    backgroundColor = colors.background,&#10;                                    shape = RoundedCornerShape(16.dp),&#10;                                    borderWidth = 3.dp,&#10;                                    animationDurationInMillis = 2500&#10;                                )&#10;                                .animateContentSize()&#10;                        } else {&#10;                            Modifier&#10;                                .background(&#10;                                    color = colors.background,&#10;                                    shape = RoundedCornerShape(16.dp)&#10;                                )&#10;                                .animateContentSize()&#10;                        }&#10;                        Box(&#10;                            modifier = boxModifier,&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;&#10;&#10;                            if (removeBg) {&#10;                                LottieAnimation(&#10;                                    composition = composition,&#10;                                    modifier = Modifier&#10;                                        .width(160.dp)&#10;                                        .aspectRatio(1f)&#10;                                        .align(Alignment.Center),&#10;                                    iterations = LottieConstants.IterateForever,&#10;                                )&#10;                                LaunchedEffect(processingStage) {&#10;                                    if (processingStage == ProcessingStage.COMPLETED ||&#10;                                        processingStage == ProcessingStage.ERROR ||&#10;                                        processingStage == ProcessingStage.NO_NETWORK_AVAILABLE&#10;                                    ) {&#10;&#10;                                        removeBackgroundBitmap = null&#10;                                    }&#10;                                }&#10;&#10;                            } else {&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .padding(16.dp)&#10;                                        .background(&#10;                                            color = colors.background,&#10;                                            shape = RoundedCornerShape(16.dp)&#10;                                        )&#10;                                        .align(Alignment.Center),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally&#10;                                ) {&#10;                                    Text(&#10;                                        &quot;${stringResource(R.string.do_you_want_to_remove_background)} \uD83D\uDC47&quot;,&#10;                                        style = MaterialTheme.typography.titleMedium,&#10;                                        textAlign = TextAlign.Center,&#10;                                        color = colors.onBackground,&#10;                                        modifier = Modifier&#10;                                            .align(Alignment.CenterHorizontally),&#10;                                    )&#10;                                    Spacer(Modifier.size(16.dp))&#10;                                    Image(&#10;                                        bitmap = bitmap,&#10;                                        contentDescription = &quot;Preview of Removed Background image&quot;&#10;                                    )&#10;                                    Spacer(Modifier.size(4.dp))&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Button(&#10;                                            onClick = { removeBackgroundBitmap = null },&#10;                                            modifier = Modifier&#10;                                                .weight(1f) // Takes 50% of the width&#10;                                                .padding(end = 3.dp)&#10;                                        ) {&#10;                                            Text(&#10;                                                stringResource(R.string.no),&#10;                                                modifier = Modifier.padding(horizontal = 10.dp)&#10;                                            )&#10;                                        }&#10;&#10;                                        Spacer(Modifier.size(6.dp))&#10;&#10;                                        Button(&#10;                                            onClick = {&#10;                                                removeBg = true&#10;                                                onRemoveBackgroundAi(bitmap)&#10;&#10;                                            },&#10;                                            modifier = Modifier&#10;                                                .weight(1f) // Takes 50% of the width&#10;                                                .padding(end = 3.dp)&#10;                                        ) {&#10;                                            Text(&#10;                                                stringResource(R.string.yes),&#10;                                                modifier = Modifier.padding(horizontal = 10.dp)&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                        }&#10;&#10;                    }&#10;                }&#10;&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showSystemUi = true, device = &quot;id:pixel_5&quot;)&#10;@Composable&#10;fun ImageProcessingScreenPreview() {&#10;&#10;    PreviewContainer {&#10;        CutOutImageScreen(&#10;            uiState = CutOutImageScreenUiState(&#10;                showLoading = false,&#10;                errorMessage = null,&#10;            ),&#10;            isPremium = false,&#10;            onBackClick = {},&#10;            onGetProClick = {}&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>